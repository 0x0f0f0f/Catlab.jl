var documenterSearchIndex = {"docs":
[{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"EditURL = \"https://github.com/epatters/Catlab.jl/blob/master/docs/literate/graphics/tikz_wiring_diagrams.jl\"","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Wiring-diagrams-in-TikZ-1","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"(Image: )","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"Catlab can draw morphism expressions as TikZ pictures. To use this feature, LaTeX must be installed and the Julia package TikzPictures.jl must be imported before Catlab is loaded.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"import TikzPictures\nusing Catlab.WiringDiagrams, Catlab.Graphics","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Examples-1","page":"Wiring diagrams in TikZ","title":"Examples","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#Symmetric-monoidal-category-1","page":"Wiring diagrams in TikZ","title":"Symmetric monoidal category","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"using Catlab.Doctrines\n\nA, B, C, D = Ob(FreeSymmetricMonoidalCategory, :A, :B, :C, :D)\nf, g = Hom(:f, A, B), Hom(:g, B, A);\nnothing #hide","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"To start, here are a few very simple examples.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(f, labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(f⋅g, labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(f⊗g, labels=true, orientation=TopToBottom)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"Here is a more complex example, involving generators with compound domains and codomains.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"h, k = Hom(:h, C, D),  Hom(:k, D, C)\nm, n = Hom(:m, B⊗A, A⊗B), Hom(:n, D⊗C, C⊗D)\nq = Hom(:l, A⊗B⊗C⊗D, D⊗C⊗B⊗A)\n\nto_tikz((f⊗g⊗h⊗k)⋅(m⊗n)⋅q⋅(n⊗m)⋅(h⊗k⊗f⊗g))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"Identities and braidings appear as wires.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(id(A), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(braid(A,B), labels=true, labels_pos=0.25)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(braid(A,B) ⋅ (g⊗f) ⋅ braid(A,B))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"The isomorphism A otimes B otimes C to C otimes B otimes A induced by the permutation (3 2 1) is a composite of braidings and identities.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz((braid(A,B) ⊗ id(C)) ⋅ (id(B) ⊗ braid(A,C) ⋅ (braid(B,C) ⊗ id(A))),\n        arrowtip=\"Stealth\", arrowtip_pos=1.0, labels=true, labels_pos=0.0)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Biproduct-category-1","page":"Wiring diagrams in TikZ","title":"Biproduct category","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"A, B = Ob(FreeBiproductCategory, :A, :B)\nf = Hom(:f, A, B)\n\nto_tikz(mcopy(A), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(delete(A), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(mcopy(A)⋅(f⊗f)⋅mmerge(B), labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Compact-closed-category-1","page":"Wiring diagrams in TikZ","title":"Compact closed category","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"The unit and co-unit of a compact closed category appear as caps and cups.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"A, B = Ob(FreeCompactClosedCategory, :A, :B)\n\nto_tikz(dunit(A), arrowtip=\"Stealth\", labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz(dcounit(A), arrowtip=\"Stealth\", labels=true)","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"In a self-dual compact closed category, such as a bicategory of relations, every morphism f A to B has a transpose f^dagger B to A given by bending wires:","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"A, B = Ob(FreeBicategoryRelations, :A, :B)\nf = Hom(:f, A, B)\n\nto_tikz((dunit(A) ⊗ id(B)) ⋅ (id(A) ⊗ f ⊗ id(B)) ⋅ (id(A) ⊗ dcounit(B)))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Abelian-bicategory-of-relations-1","page":"Wiring diagrams in TikZ","title":"Abelian bicategory of relations","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"In an abelian bicategory of relations, such as the category of linear relations, the duplication morphisms Delta_X X to X otimes X and addition morphisms blacktriangledown_X X otimes X to X belong to a bimonoid. Among other things, this means that the following two morphisms are equal.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_tikz(mplus(X) ⋅ mcopy(X))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"to_tikz((mcopy(X)⊗mcopy(X)) ⋅ (id(X)⊗braid(X,X)⊗id(X)) ⋅ (mplus(X)⊗mplus(X)))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Custom-styles-1","page":"Wiring diagrams in TikZ","title":"Custom styles","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"The visual appearance of wiring diagrams can be customized using the builtin options or by redefining the TikZ styles for the boxes or wires.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"A, B, = Ob(FreeSymmetricMonoidalCategory, :A, :B)\nf, g = Hom(:f, A, B), Hom(:g, B, A)\n\npic = to_tikz(f⋅g, styles=Dict(\n  \"box\" => [\"draw\", \"fill\"=>\"{rgb,255: red,230; green,230; blue,250}\"],\n))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_tikz(mplus(X) ⋅ mcopy(X), styles=Dict(\n  \"junction\" => [\"circle\", \"draw\", \"fill\"=>\"red\", \"inner sep\"=>\"0\"],\n  \"variant junction\" => [\"circle\", \"draw\", \"fill\"=>\"blue\", \"inner sep\"=>\"0\"],\n))","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#Output-formats-1","page":"Wiring diagrams in TikZ","title":"Output formats","text":"","category":"section"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"The function to_tikz returns an object of type TikZ.Picture, representing a TikZ picture has an abstract syntax tree. When displayed interactively, this object is compiled by LaTeX to PDF and then converted to SVG.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"To generate the LaTeX source code, use the builtin pretty-printer. This feature does not require LaTeX or TikzPictures.jl to be installed.","category":"page"},{"location":"generated/graphics/tikz_wiring_diagrams/#","page":"Wiring diagrams in TikZ","title":"Wiring diagrams in TikZ","text":"import Catlab.Graphics: TikZ\n\npic = to_tikz(f⋅g)\nTikZ.pprint(pic)","category":"page"},{"location":"apis/programs/#Programs-1","page":"Programs","title":"Programs","text":"","category":"section"},{"location":"apis/programs/#","page":"Programs","title":"Programs","text":"CurrentModule = Catlab.Programs","category":"page"},{"location":"apis/programs/#","page":"Programs","title":"Programs","text":"Modules = [\n  JuliaPrograms,\n  AlgebraicNets,\n  ExpressionTrees,\n]\nPrivate = false","category":"page"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms","page":"Programs","title":"Catlab.Programs.JuliaPrograms","text":"Morphisms as Julia programs.\n\nThis module allows morphisms in a symmetric monoidal category to be converted to and from programs in a subset of the Julia language.\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.Block","page":"Programs","title":"Catlab.Programs.JuliaPrograms.Block","text":"A block of Julia code with input and output variables.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.CompileState","page":"Programs","title":"Catlab.Programs.JuliaPrograms.CompileState","text":"Internal state for compilation of morphism into Julia code.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.compile-Tuple{Catlab.Doctrines.HomExpr}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.compile","text":"Compile a morphism expression into a Julia function.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.compile_block-Tuple{Catlab.Doctrines.HomExpr,Array{T,1} where T}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.compile_block","text":"Compile a morphism expression into a block of Julia code.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.compile_expr-Tuple{Catlab.Doctrines.HomExpr}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.compile_expr","text":"Compile a morphism expression into a Julia function expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.parse_wiring_diagram-Tuple{Presentation,Expr}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.parse_wiring_diagram","text":"Parse a wiring diagram from a Julia function expression.\n\nSee also: @parse_wiring_diagram\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.@parse_wiring_diagram-Tuple{Any,Any}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.@parse_wiring_diagram","text":"Parse a wiring diagram from Julia code.\n\nFor the most part, this is standard Julia but we take a few liberties with the syntax. Products are represented as tuples. So if x and y are variables of type X and Y, then (x,y) has type X otimes Y. Also, both () and nothing are interpreted as the monoidal unit I.\n\nUnlike in standard Julia, the call expressions f(x,y) and f((x,y)) are equivalent. Consequently, given morphisms f W to X otimes Y and g X otimes Y to Z, the code\n\nx, y = f(w)\ng(x,y)\n\nis equivalent to g(f(w)). In standard Julia, at most one of these calls to g would be valid.\n\nThe diagonals (copying and deleting) are implicit in the Julia syntax: copying is variable reuse and deleting is variable non-use. For the codiagonals (merging and creating), a special syntax is provided, reinterpreting Julia's vector literals. The merge of x1 and x2 is represented by the vector [x1,x2] and creation by the empty vector []. For example, f([x1,x2]) translates to compose(mmerge(X),f).\n\n\n\n\n\n","category":"macro"},{"location":"apis/programs/#Catlab.Programs.AlgebraicNets","page":"Programs","title":"Catlab.Programs.AlgebraicNets","text":"Computer algebra via monoidal categories.\n\nIn a conventional computer algebra system, algebraic expressions are represented as trees whose leaves are variables or constants and whose internal nodes are arithmetic operations or elementary or special functions. The idea here is to represent expressions as morphisms in a monoidal category.\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.AlgebraicNets.AlgebraicNetSignature","page":"Programs","title":"Catlab.Programs.AlgebraicNets.AlgebraicNetSignature","text":"Doctrine of algebraic networks\n\nTODO: Explain\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.AlgebraicNets.compile_expr_vector-Tuple{Catlab.Programs.AlgebraicNets.AlgebraicNet.Hom}","page":"Programs","title":"Catlab.Programs.AlgebraicNets.compile_expr_vector","text":"Compile an algebraic network into a Julia function expression.\n\nThe function signature is:\n\nfirst argument = input vector\nsecond argument = constant (coefficients) vector\n\nUnlike compile_expr, this method assumes the network has a single output.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.AlgebraicNets.evaluate-Tuple{Catlab.Programs.AlgebraicNets.AlgebraicNet.Hom,Vararg{Any,N} where N}","page":"Programs","title":"Catlab.Programs.AlgebraicNets.evaluate","text":"Evaluate an algebraic network without first compiling it.\n\nIf the network will only be evaluated once (possibly with vectorized inputs), then direct evaluation will be much faster than compiling with Julia's JIT.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.compile-Tuple{Union{Catlab.Programs.JuliaPrograms.Block, Catlab.Programs.AlgebraicNets.AlgebraicNet.Hom}}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.compile","text":"Compile an algebraic network into a Julia function.\n\nThis method of \"functorial compilation\" generates simple imperative code with no optimizations. Still, the code should be fast provided the original expression is properly factored, with no duplicate computations.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.compile_block-Tuple{Catlab.Programs.AlgebraicNets.AlgebraicNet.Hom,Array{T,1} where T}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.compile_block","text":"Compile an algebraic network into a block of Julia code.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.JuliaPrograms.compile_expr-Tuple{Catlab.Programs.AlgebraicNets.AlgebraicNet.Hom}","page":"Programs","title":"Catlab.Programs.JuliaPrograms.compile_expr","text":"Compile an algebraic network into a Julia function expression.\n\nThe function signature is:\n\narguments = inputs (domain) of network\nkeyword arguments = symbolic constants (coefficients) of network, if any\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.ExpressionTrees","page":"Programs","title":"Catlab.Programs.ExpressionTrees","text":"Expression trees (formulas) for computer algebra.\n\nThis module is not an implementation of a conventional, general-purpose CAS. There are already many outstanding computer algebra systems. Its goals are to\n\nrepresent formulas as expression tree, when that is convenient\ndisplay formulas in conventional mathematical notation with free variables\nallow interoperation with existing computer algebra systems\n\n\n\n\n\n","category":"module"},{"location":"apis/programs/#Catlab.Programs.ExpressionTrees.Formula","page":"Programs","title":"Catlab.Programs.ExpressionTrees.Formula","text":"An expression tree for computer algebra.\n\nWe call the expression trees \"formulas\" to avoid confusion with Julia expressions (Base.Expr) or GAT expressions (Catlab.Syntax.GATExpr). Usually the operations (head symbols) are interpreted as Julia functions, e.g., :/ is right multiplication by the matrix pseudoinverse while :./ is the elementwise division.\n\n\n\n\n\n","category":"type"},{"location":"apis/programs/#Base.Meta.show_sexpr-Tuple{Catlab.Programs.ExpressionTrees.Formula}","page":"Programs","title":"Base.Meta.show_sexpr","text":"Show the formula as an S-expression.\n\nCf. the standard library function Meta.show_sexpr.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.ExpressionTrees.to_formula-Tuple{Catlab.Programs.AlgebraicNets.AlgebraicNet.Hom,Array{Symbol,1}}","page":"Programs","title":"Catlab.Programs.ExpressionTrees.to_formula","text":"Convert algebraic network to formula.\n\nAssumes that the network has a single output.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Programs.ExpressionTrees.to_formula-Tuple{Expr}","page":"Programs","title":"Catlab.Programs.ExpressionTrees.to_formula","text":"Convert Julia expression to formula.\n\nOnly a subset of the Julia syntax is supported.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.Syntax.show_latex-Tuple{Catlab.Programs.ExpressionTrees.Formula}","page":"Programs","title":"Catlab.Syntax.show_latex","text":"Show the expression in infix notation using LaTeX math.\n\nDoes not include $ or \\[begin|end]{equation} delimiters.\n\n\n\n\n\n","category":"method"},{"location":"apis/programs/#Catlab.WiringDiagrams.WiringLayers.to_wiring_diagram-Tuple{Catlab.Programs.ExpressionTrees.Formula,Array{Symbol,1}}","page":"Programs","title":"Catlab.WiringDiagrams.WiringLayers.to_wiring_diagram","text":"Convert a formula, or formulas, to a wiring diagram.\n\nThe wiring diagram has an input for each symbol in vars and an output for each given formula. All terminal symbols not appearing in vars are treated as symbolic constants.\n\nThe algorithm creates wiring diagrams in normal form for a cartesian category, meaning that subformulas are maximally shared (cf. normalize_copy! for wiring diagrams and the congruence closure algorithm).\n\n\n\n\n\n","category":"method"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"EditURL = \"https://github.com/epatters/Catlab.jl/blob/master/docs/literate/wiring_diagrams/wiring_diagram_basics.jl\"","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Basics-of-wiring-diagrams-1","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"(Image: )","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"Using Catlab, you can create, manipulate, serialize, and visualize wiring diagrams, also known as string diagrams. The flexible data structure for wiring diagrams allows arbitrary data to be attached to boxes, ports, and wires, and supports recursively nested diagrams.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"You can interact with wiring diagrams using two different progamming interfaces:","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"Categorical: A high-level, functional interface expressed in terms of categorical concepts, such as composition (compose), monoidal products (otimes), duplication (mcopy), and deletion (delete).\nImperative: A lower-level, mutating interface to directly manipulate boxes, ports, and wires, via operations like adding boxes (add_box) and wires (add_wire).","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"In this notebook, we introduce both interfaces. We do not explicitly cover the visualization API, although for illustrative purposes we will draw wiring diagrams using Graphviz. Thus, you should install Graphviz if you wish to run this notebook.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"using Catlab.WiringDiagrams\n\nusing Catlab.Graphics\nimport Catlab.Graphics: Graphviz\n\nshow_diagram(d::WiringDiagram) = to_graphviz(d,\n  orientation=LeftToRight,\n  labels=true, label_attr=:xlabel,\n  node_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  ),\n  edge_attrs=Graphviz.Attributes(\n    :fontname => \"Courier\",\n  )\n)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Data-structures-1","page":"Basics of wiring diagrams","title":"Data structures","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The basic building blocks of a wiring diagram are boxes, ports, and wires. The top-level data structure is WiringDiagram, defined in the module Catlab.WiringDiagrams. A wiring diagram consists of boxes (usually of type Box) connected by wires (of type Wire). Each box has a sequence of input ports and a sequence of output ports, as does the wiring diagram itself. The wires have sources and targets, both of which consist of a box and a port on that box.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The boxes in a wiring diagram are indexed by integer IDs. Boxes can be retrieved by ID, and wires refer to boxes using their IDs. Two special IDs, obtained by input_id and output_id methods, refer to the inputs and outputs of the diagram itself. In this way, wires can connect the (inner) boxes of a diagram to the diagram's \"outer box\".","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The WiringDiagram data structure is an elaborate wrapper around a directed graph from LightGraphs.jl. The underlying DiGraph object can be accessed using the graph method. The vertices of this graph are exactly the box IDs. The graph should never be mutated directly, on pain of creating inconsistent state, but it does allow convenient access to the large array of graph algorithms supported by LightGraphs.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"All this is somewhat abstract but should become clearer as we see concrete examples.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Categorical-interface-1","page":"Basics of wiring diagrams","title":"Categorical interface","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"In this example, the wiring diagrams will carry symbolic expressions (of type Catlab.ObExpr and Catlab.HomExpr).","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"using Catlab.Doctrines\n\nA, B, C, D = Ob(FreeBiproductCategory, :A, :B, :C, :D)\nf = Hom(:f, A, B)\ng = Hom(:g, B, C)\nh = Hom(:h, C, D)\n\nf","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Generators-1","page":"Basics of wiring diagrams","title":"Generators","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"Convert each of the morphism generators into a diagram with a single box.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"f, g, h = to_wiring_diagram(f), to_wiring_diagram(g), to_wiring_diagram(h)\nf","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(f)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Composition-1","page":"Basics of wiring diagrams","title":"Composition","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"compose(f,g)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(compose(f,g))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Monoidal-products-1","page":"Basics of wiring diagrams","title":"Monoidal products","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"otimes(f,h)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(otimes(f,h))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Copy-and-merge,-delete-and-create-1","page":"Basics of wiring diagrams","title":"Copy and merge, delete and create","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"mcopy(codom(f),2)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(mcopy(codom(f),2))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(compose(f, mcopy(codom(f),2)))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(compose(mcopy(dom(f),2), otimes(f,f)))","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Imperative-interface-1","page":"Basics of wiring diagrams","title":"Imperative interface","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"We now show how to manipulate wiring diagrams using the low-level, imperative interface. The diagrams will carry Julia symbols.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"f = Box(:f, [:A], [:B])\ng = Box(:g, [:B], [:C])\nh = Box(:h, [:C], [:D])\n\nf","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Composition-2","page":"Basics of wiring diagrams","title":"Composition","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"For example, here is how to manually construct a composition of two boxes.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"The add_box! method adds a box to a wiring diagrams and returns the ID assigned to the box. How the boxes are indexed is an implementation detail that you should not rely on; use the IDs that the system gives you.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"d = WiringDiagram([:A], [:C])\n\nfv = add_box!(d, f)\ngv = add_box!(d, g)\n\nadd_wires!(d, [\n  (input_id(d),1) => (fv,1),\n  (fv,1) => (gv,1),\n  (gv,1) => (output_id(d),1),\n])\n\nnboxes(d)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"nwires(d)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"d","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(d)","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#Products-1","page":"Basics of wiring diagrams","title":"Products","text":"","category":"section"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"Here is how to manually construct a product of two boxes.","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"d = WiringDiagram([:A,:C], [:B,:D])\n\nfv = add_box!(d, f)\nhv = add_box!(d, h)\n\nadd_wires!(d, [\n  (input_id(d),1) => (fv,1),\n  (input_id(d),2) => (hv,1),\n  (fv,1) => (output_id(d),1),\n  (hv,1) => (output_id(d),2),\n])\n\nd","category":"page"},{"location":"generated/wiring_diagrams/wiring_diagram_basics/#","page":"Basics of wiring diagrams","title":"Basics of wiring diagrams","text":"show_diagram(d)","category":"page"},{"location":"apis/doctrines/#Doctrines-1","page":"Doctrines","title":"Doctrines","text":"","category":"section"},{"location":"apis/doctrines/#","page":"Doctrines","title":"Doctrines","text":"CurrentModule = Catlab","category":"page"},{"location":"apis/doctrines/#","page":"Doctrines","title":"Doctrines","text":"Modules = [Doctrines,\n          Catlab.Doctrines.AbelianBicategoryRelations,\n          Catlab.Doctrines.BicategoryRelations,\n          Catlab.Doctrines.BiproductCategory,\n          Catlab.Doctrines.CartesianCategory,\n          Catlab.Doctrines.CartesianClosedCategory,\n          Catlab.Doctrines.Category,\n          Catlab.Doctrines.Category2,\n          Catlab.Doctrines.CocartesianCategory,\n          Catlab.Doctrines.CompactClosedCategory,\n          Catlab.Doctrines.DaggerCategory,\n          Catlab.Doctrines.DaggerCompactCategory,\n          Catlab.Doctrines.FreeAbelianBicategoryRelations,\n          Catlab.Doctrines.FreeBicategoryRelations,\n          Catlab.Doctrines.FreeBiproductCategory,\n          Catlab.Doctrines.FreeCartesianCategory,\n          Catlab.Doctrines.FreeCartesianClosedCategory,\n          Catlab.Doctrines.FreeCategory,\n          Catlab.Doctrines.FreeCategory2,\n          Catlab.Doctrines.FreeCocartesianCategory,\n          Catlab.Doctrines.FreeCompactClosedCategory,\n          Catlab.Doctrines.FreeDaggerCategory,\n          Catlab.Doctrines.FreeDaggerCompactCategory,\n          Catlab.Doctrines.FreeSymmetricMonoidalCategory,\n          Catlab.Doctrines.MonoidalCategory,\n          Catlab.Doctrines.MonoidalCategoryWithBidiagonals,\n          Catlab.Doctrines.MonoidalCategoryWithCodiagonals,\n          Catlab.Doctrines.MonoidalCategoryWithDiagonals,\n          Catlab.Doctrines.SymmetricMonoidalCategory,\n          ]\nPrivate = false","category":"page"},{"location":"apis/doctrines/#Catlab.Doctrines.AbelianBicategoryRelations","page":"Doctrines","title":"Catlab.Doctrines.AbelianBicategoryRelations","text":"Doctrine of abelian bicategory of relations\n\nUnlike Carboni & Walters, we use additive notation and nomenclature.\n\nReferences:\n\nCarboni & Walters, 1987, \"Cartesian bicategories I\", Sec. 5\nBaez & Erbele, 2015, \"Categories in control\"\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.BicategoryRelations","page":"Doctrines","title":"Catlab.Doctrines.BicategoryRelations","text":"Doctrine of bicategory of relations\n\nTODO: The 2-morphisms are missing. I haven't decided how to handle them yet.\n\nReferences:\n\nCarboni & Walters, 1987, \"Cartesian bicategories I\"\nWalters, 2009, blog post, \"Categorical algebras of relations\", http://rfcwalters.blogspot.com/2009/10/categorical-algebras-of-relations.html\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.BiproductCategory","page":"Doctrines","title":"Catlab.Doctrines.BiproductCategory","text":"Doctrine of bicategory category\n\nAlso known as a semiadditive category.\n\nFIXME: This signature should extend MonoidalCategoryWithBidiagonals, CartesianCategory, and CocartesianCategory, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianCategory","page":"Doctrines","title":"Catlab.Doctrines.CartesianCategory","text":"Doctrine of cartesian category\n\nActually, this is a cartesian symmetric monoidal category but we omit these qualifiers for brevity.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianClosedCategory","page":"Doctrines","title":"Catlab.Doctrines.CartesianClosedCategory","text":"Doctrine of cartesian closed category (aka, CCC)\n\nA CCC is a cartesian category with internal homs (aka, exponential objects).\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.Category","page":"Doctrines","title":"Catlab.Doctrines.Category","text":"Doctrine of category (with no extra structure)\n\nWarning: We compose functions from left to right, i.e., if f:A→B and g:B→C then compose(f,g):A→C. Under this convention function are applied on the right, e.g., if a∈A then af∈B.\n\nWe retain the usual meaning of the symbol ∘ (\\circ), i.e., g∘f = compose(f,g). This usage is too entrenched to overturn, inconvenient though it may be. We use symbol ⋅ (\\cdot) for diagrammatic composition: f⋅g = compose(f,g).\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2","page":"Doctrines","title":"Catlab.Doctrines.Category2","text":"Doctrine of (strict) 2-category\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CocartesianCategory","page":"Doctrines","title":"Catlab.Doctrines.CocartesianCategory","text":"Doctrine of cocartesian category\n\nActually, this is a cocartesian symmetric monoidal category but we omit these qualifiers for brevity.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CompactClosedCategory","page":"Doctrines","title":"Catlab.Doctrines.CompactClosedCategory","text":"Doctrine of compact closed category\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCategory","page":"Doctrines","title":"Catlab.Doctrines.DaggerCategory","text":"Doctrine of dagger category\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCompactCategory","page":"Doctrines","title":"Catlab.Doctrines.DaggerCompactCategory","text":"Doctrine of dagger compact category\n\nIn a dagger compact category, there are two kinds of adjoints of a morphism f::Hom(A,B), the adjoint mate mate(f)::Hom(dual(B),dual(A)) and the dagger adjoint dagger(f)::Hom(B,A). In the category of Hilbert spaces, these are respectively the Banach space adjoint and the Hilbert space adjoint (Reed-Simon, Vol I, Sec VI.2). In Julia, they would correspond to transpose and adjoint in the official LinearAlegbra module. For the general relationship between mates and daggers, see Selinger's survey of graphical languages for monoidal categories.\n\nFIXME: This signature should extend both DaggerCategory and CompactClosedCategory, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerSymmetricMonoidalCategory","page":"Doctrines","title":"Catlab.Doctrines.DaggerSymmetricMonoidalCategory","text":"Doctrine of dagger symmetric monoidal category\n\nAlso known as a symmetric monoidal dagger category.\n\nFIXME: This signature should extend both DaggerCategory and SymmetricMonoidalCategory, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianCategory","page":"Doctrines","title":"Catlab.Doctrines.FreeCartesianCategory","text":"Syntax for a free cartesian category.\n\nIn this syntax, the pairing and projection operations are defined using duplication and deletion, and do not have their own syntactic elements. Of course, this convention could be reversed.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianClosedCategory","page":"Doctrines","title":"Catlab.Doctrines.FreeCartesianClosedCategory","text":"Syntax for a free cartesian closed category.\n\nSee also FreeCartesianCategory.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2","page":"Doctrines","title":"Catlab.Doctrines.FreeCategory2","text":"Syntax for a 2-category.\n\nChecks domains of morphisms but not 2-morphisms.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCocartesianCategory","page":"Doctrines","title":"Catlab.Doctrines.FreeCocartesianCategory","text":"Syntax for a free cocartesian category.\n\nIn this syntax, the copairing and inclusion operations are defined using merging and creation, and do not have their own syntactic elements. Of course, this convention could be reversed.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategory","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategory","text":"Doctrine of monoidal category\n\nTo avoid associators and unitors, we assume the monoidal category is strict. By the coherence theorem there is no loss of generality, but we may add a signature for weak monoidal categories later.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithBidiagonals","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithBidiagonals","text":"Doctrine of monoidal category with bidiagonals\n\nThe terminology is nonstandard (is there any standard terminology?) but is intended to mean a monoidal category with coherent diagonals and codiagonals. Unlike in a biproduct category, the naturality axioms need not be satisfied.\n\nFIXME: This signature should extend both MonoidalCategoryWithDiagonals and MonoidalCategoryWithCodiagonals, but multiple inheritance is not yet supported.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithCodiagonals","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithCodiagonals","text":"Doctrine of monoidal category with codiagonals\n\nA monoidal category with codiagonals is a symmetric monoidal category equipped with coherent collections of merging and creating morphisms (monoids). Unlike in a cocartesian category, the naturality axioms need not be satisfied.\n\nFor references, see MonoidalCategoryWithDiagonals.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithDiagonals","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithDiagonals","text":"Doctrine of monoidal category with diagonals\n\nA monoidal category with diagonals is a symmetric monoidal category equipped with coherent collections of copying and deleting morphisms (comonoids). Unlike in a cartesian category, the naturality axioms need not be satisfied.\n\nReferences:\n\nSelinger, 2010, \"A survey of graphical languages for monoidal categories\", Section 6.6: \"Cartesian center\"\nSelinger, 1999, \"Categorical structure of asynchrony\"\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.SymmetricMonoidalCategory","page":"Doctrines","title":"Catlab.Doctrines.SymmetricMonoidalCategory","text":"Doctrine of symmetric monoidal category\n\nThe signature (but not the axioms) is the same as a braided monoidal category.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Base.collect-Tuple{Catlab.Doctrines.ObExpr}","page":"Doctrines","title":"Base.collect","text":"Collect generators of object in monoidal category as a vector.\n\n\n\n\n\n","category":"method"},{"location":"apis/doctrines/#Base.ndims-Tuple{Catlab.Doctrines.ObExpr}","page":"Doctrines","title":"Base.ndims","text":"Number of \"dimensions\" of object in monoidal category.\n\n\n\n\n\n","category":"method"},{"location":"apis/doctrines/#Catlab.Doctrines.AbelianBicategoryRelations.Hom","page":"Doctrines","title":"Catlab.Doctrines.AbelianBicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.AbelianBicategoryRelations.Ob","page":"Doctrines","title":"Catlab.Doctrines.AbelianBicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BicategoryRelations.Hom","page":"Doctrines","title":"Catlab.Doctrines.BicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BicategoryRelations.Ob","page":"Doctrines","title":"Catlab.Doctrines.BicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BiproductCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.BiproductCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BiproductCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.BiproductCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.CartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.CartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianClosedCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.CartesianClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianClosedCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.CartesianClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category.Hom","page":"Doctrines","title":"Catlab.Doctrines.Category.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category.Ob","page":"Doctrines","title":"Catlab.Doctrines.Category.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2.Hom","page":"Doctrines","title":"Catlab.Doctrines.Category2.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2.Hom2","page":"Doctrines","title":"Catlab.Doctrines.Category2.Hom2","text":"2-morphism in a 2-category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2.Ob","page":"Doctrines","title":"Catlab.Doctrines.Category2.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CocartesianCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.CocartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CocartesianCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.CocartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CompactClosedCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.CompactClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CompactClosedCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.CompactClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.DaggerCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.DaggerCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCompactCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.DaggerCompactCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCompactCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.DaggerCompactCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeAbelianBicategoryRelations.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeAbelianBicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeAbelianBicategoryRelations.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeAbelianBicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBicategoryRelations.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeBicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBicategoryRelations.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeBicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBiproductCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeBiproductCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBiproductCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeBiproductCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeCartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeCartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianClosedCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeCartesianClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianClosedCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeCartesianClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeCategory2.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2.Hom2","page":"Doctrines","title":"Catlab.Doctrines.FreeCategory2.Hom2","text":"2-morphism in a 2-category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeCategory2.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCocartesianCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeCocartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCocartesianCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeCocartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCompactClosedCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeCompactClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCompactClosedCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeCompactClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeDaggerCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeDaggerCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCompactCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeDaggerCompactCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCompactCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeDaggerCompactCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeSymmetricMonoidalCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.FreeSymmetricMonoidalCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeSymmetricMonoidalCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.FreeSymmetricMonoidalCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Hom","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Ob","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Hom","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Ob","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithDiagonals.Hom","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithDiagonals.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithDiagonals.Ob","page":"Doctrines","title":"Catlab.Doctrines.MonoidalCategoryWithDiagonals.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.SymmetricMonoidalCategory.Hom","page":"Doctrines","title":"Catlab.Doctrines.SymmetricMonoidalCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.SymmetricMonoidalCategory.Ob","page":"Doctrines","title":"Catlab.Doctrines.SymmetricMonoidalCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"EditURL = \"https://github.com/epatters/Catlab.jl/blob/master/docs/literate/programs/algebraic_nets.jl\"","category":"page"},{"location":"generated/programs/algebraic_nets/#Algebraic-networks-1","page":"Algebraic networks","title":"Algebraic networks","text":"","category":"section"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"(Image: )","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"using Catlab.Programs\n\nimport TikzPictures\nusing Catlab.Graphics","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"R = Ob(AlgebraicNet, \"\\\\mathbb{R}\")\nf_sin = Hom(:sin, R, R)\nf_cos = Hom(:cos, R, R)\ndisplay(f_sin)\ndisplay(f_cos)","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"f = compose(mcopy(R),otimes(f_sin,f_cos),mmerge(R))","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"to_tikz(f, labels=true)","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"compile_expr(f; args=[:x])","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"to_formula(f, [:x])","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"f = compose(mcopy(R,3), otimes(f_sin, f_cos, f_sin))","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"to_tikz(f)","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"compile_expr(f; args=[:x])","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"f = compose(linear(2,R,R), f_sin, linear(2,R,R))","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"to_tikz(f)","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"compile_expr(f; args=[:x])","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"to_formula(f, [:x])","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"f = compose(mcopy(R), otimes(id(R),Hom(:cos,R,R)), Hom(:*,otimes(R,R),R))","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"to_tikz(f)","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"compile_expr(f; args=[:x])","category":"page"},{"location":"generated/programs/algebraic_nets/#","page":"Algebraic networks","title":"Algebraic networks","text":"to_formula(f, [:x])","category":"page"},{"location":"apis/core/#Symbolic-expressions-1","page":"Symbolic expressions","title":"Symbolic expressions","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"CurrentModule = Catlab","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"At the core of Catlab is a system for defining and manipulating symbolic expressions in typed algebraic structures, including categories and monoidal categories. Objects, morphisms, and even higher-order morphisms are represented as typed symbolic expressions. The expressions can be manipulated abstractly or transformed, usually functorially, into more concrete representations, such as wiring diagrams or Julia functions.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"The basic elements of this system are:","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Signatures of generalized algebraic theories (GATs), defined using the  @signature macro. Categories and other typed (multisorted) algebraic structures can be defined as GATs.\nInstances, or concrete implementations, of signatures, asserted using the @instance macro.\nSyntax systems for signatures, defined using the @syntax macro. These are type-safe expression trees constructed using ordinary Julia functions.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"We'll explain each of these elements in greater detail in the following sections. From the programming perspective, signatures can be thought of as interfaces and bear some resemblance to type classes. Both instances and syntax systems then act as implementations of the interface.","category":"page"},{"location":"apis/core/#Signatures-1","page":"Symbolic expressions","title":"Signatures","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Generalized algebraic theories (GATs) are the natural logical system in which to define categories and related algebraic structures. GATs generalize the typed (multisorted) algebraic theories of universal algebra by incorporating a fragment of dependent type theory; they are perhaps the simplest dependently typed logics.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Catlab implements a version of the GAT formalism on top of Julia's type system, taking advantage of Julia macros to provide a pleasant syntax. Signatures of GATs are defined using the @signature macro.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"For example, the signature of the theory of categories could be defined by:","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"using Catlab\nimport Catlab.Doctrines: Ob, Hom, ObExpr, HomExpr, dom, codom, compose, id","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"@signature Category(Ob,Hom) begin\n  Ob::TYPE\n  Hom(dom::Ob, codom::Ob)::TYPE\n  \n  id(A::Ob)::Hom(A,A)\n  compose(f::Hom(A,B), g::Hom(B,C))::Hom(A,C) <= (A::Ob, B::Ob, C::Ob)\nend\nnothing # hide","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"The code is simplified only slightly from the official Catlab definition of Category. The signature has two type constructors, Ob (object) and Hom (morphism). The type Hom is a dependent type, depending on two objects, named dom (domain) and codom (codomain). The signature has two term constructors, id (identity) and compose (composition).","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Notice how the return types of the term constructors depend on the argument values. For example, the term id(A) has type Hom(A,A). The term constructor compose also uses context variables, listed to the right of the <= symbol. This allows us to write compose(f,g), instead of the more verbose compose(A,B,C,f,g) (for discussion, see Cartmell, 1986, Sec 10: Informal syntax).","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"note: Note\nIn general, a GAT consists of a signature, defining the types and terms of the theory, and a set of axioms, the equational laws satisfied by models of the theory. The theory of categories, for example, has axioms of unitality and associativity. At present, Catlab supports the specification of signatures, but not of axioms, reflecting its status as a programming library, not a proof assistant. It is the programmer's responsibility to ensure any declared instances of an algebraic structure satisfy its axioms.","category":"page"},{"location":"apis/core/#References-1","page":"Symbolic expressions","title":"References","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Cartmell, 1986: Generalized algebraic theories and contextual categories, DOI:10.1016/0168-0072(86)90053-9\nCartmell, 1978, PhD thesis: Generalized algebraic theories and contextual categories\nPitts, 1995: Categorical logic, Sec 6: Dependent types","category":"page"},{"location":"apis/core/#Instances-1","page":"Symbolic expressions","title":"Instances","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"A signature can have one or more instances, or instantiations by ordinary Julia types and functions. This feature builds on Julia's support for generic functions with multiple dispatch.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Instances are declared using the @instance macro. In an instance of a signature, each signature type is mapped to a Julia type and each term is mapped to a Julia method of the same name. For example, the category of matrices could be defined as an instance of the signature Category defined above:","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"using LinearAlgebra: I\n\nstruct MatrixDomain\n  eltype::Type\n  dim::Int\nend\n\n@instance Category(MatrixDomain, Matrix) begin\n  dom(M::Matrix) = MatrixDomain(eltype(M), size(M,1))\n  codom(M::Matrix) = MatrixDomain(eltype(M), size(M,2))\n  \n  id(m::MatrixDomain) = Matrix{m.eltype}(I, m.dim, m.dim)\n  compose(M::Matrix, N::Matrix) = M*N\nend","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"A = Matrix{Float64}([0 1; 1 0])\nid(dom(A))","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"In this instance, the signature type Ob is mapped to the custom Julia type MatrixDomain. The latter type has two fields, a Julia type eltype representing a field k and an integer dim representing the dimensionality n, and so can be interpreted as the n-dimensional vector space k^n. The signature Hom is mapped to the standard Julia type Matrix.","category":"page"},{"location":"apis/core/#Syntax-systems-1","page":"Symbolic expressions","title":"Syntax systems","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Signatures can also be instantiated as systems of symbolic expressions, using the @syntax macro. The symbolic expressions are expression trees, as commonly used in computer algebra systems. They are similar to Julia's Expr type but they are instead subtyped from Catlab's GATExpr type and they have a more refined type hierarchy.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"A single signature can have different syntax systems, treating different terms as primitive or performing different simplication or normalization procedures. Catlab tries to make it easy to define new syntax systems. Many of the signatures included with Catlab have default syntax systems, but the user is encouraged to define their own to suit their needs.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"To get started, you can always call the @syntax macro with an empty body. Below, we subtype from Catlab's abstract types ObExpr and HomExpr to enable LaTeX pretty-printing and other convenient features, but this is not required.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"@syntax CategoryExprs(ObExpr, HomExpr) Category begin\nend\n\nA, B, C, D = [ Ob(CategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]\nf, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)\n\ncompose(compose(f,g),h)","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"The resulting symbolic expressions perform no simplification. For example, the associativity law is not satisfied:","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"compose(compose(f,g),h) == compose(f,compose(g,h))","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Thus, unlike instances of a theory, syntactic expressions are not expected to obey all the axioms of the theory.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"However, the user may supply logic in the body of the @syntax macro to enforce the axioms or perform other kinds of simplification. Below, we use the associate function provided by Catlab to convert the binary expressions representing composition into n-ary expressions for any number n. The option strict=true tells Catlab to check that the domain and codomain objects are strictly equal and throw an error if they are not.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"@syntax SimplifyingCategoryExprs(ObExpr, HomExpr) Category begin\n  compose(f::Hom, g::Hom) = associate(new(f,g; strict=true))\nend\n\nA, B, C, D = [ Ob(SimplifyingCategoryExprs.Ob, X) for X in [:A, :B, :C, :D] ]\nf, g, h = Hom(:f, A, B), Hom(:g, B, C), Hom(:h, C, D)\n\ncompose(compose(f,g),h)","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Now the associativity law is satisfied:","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"compose(compose(f,g),h) == compose(f,compose(g,h))","category":"page"},{"location":"apis/core/#Primitive-versus-derived-operations-1","page":"Symbolic expressions","title":"Primitive versus derived operations","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"In some algebraic structures, there is a choice as to which operations should be considered primitive and which should be derived. For example, in a cartesian monoidal category, the copy operation Delta_X X to X otimes X can be defined in terms of the pairing operation langle f g rangle, or vice versa. In addition, the projections pi_XY X otimes Y to X and pi_XY X otimes Y to Y can be defined in terms of the deleting operation (terminal morphism) or left as primitive.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"In Catlab, the recommended way to deal with such situations is to define all the operations in the signature and then allow particular syntax systems to determine which operations, if any, will be derived from others. In the case of the cartesian monoidal category, we could define a signature CartesianCategory by inheriting from the builtin signature SymmetricMonoidalCategory.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"using Catlab\nimport Catlab.Doctrines: Ob, Hom, ObExpr, HomExpr, SymmetricMonoidalCategory,\n  dom, codom, compose, id, otimes, munit, braid","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"@signature SymmetricMonoidalCategory(Ob,Hom) => CartesianCategory(Ob,Hom) begin\n  mcopy(A::Ob)::Hom(A,otimes(A,A))\n  delete(A::Ob)::Hom(A,munit())\n  \n  pair(f::Hom(A,B), g::Hom(A,C))::Hom(A,otimes(B,C)) <= (A::Ob, B::Ob, C::Ob)\n  proj1(A::Ob, B::Ob)::Hom(otimes(A,B),A)\n  proj2(A::Ob, B::Ob)::Hom(otimes(A,B),B)\nend\nnothing # hide","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"We could then define the copying operation in terms of the pairing.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"@syntax CartesianCategoryExprsV1(ObExpr,HomExpr) CartesianCategory begin\n  mcopy(A::Ob) = pair(id(A), id(A))\nend\n\nA = Ob(CartesianCategoryExprsV1.Ob, :A)\nmcopy(A)","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Alternatively, we could define the pairing and projections in terms of the copying and deleting operations.","category":"page"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"@syntax CartesianCategoryExprsV2(ObExpr,HomExpr) CartesianCategory begin\n  pair(f::Hom, g::Hom) = compose(mcopy(dom(f)), otimes(f,g))\n  proj1(A::Ob, B::Ob) = otimes(id(A), delete(B))\n  proj2(A::Ob, B::Ob) = otimes(delete(A), id(B))\nend\n\nA, B, C = [ Ob(CartesianCategoryExprsV2.Ob, X) for X in [:A, :B, :C] ]\nf, g = Hom(:f, A, B), Hom(:g, A, C)\npair(f, g)","category":"page"},{"location":"apis/core/#Presentations-1","page":"Symbolic expressions","title":"Presentations","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"TODO","category":"page"},{"location":"apis/core/#API-1","page":"Symbolic expressions","title":"API","text":"","category":"section"},{"location":"apis/core/#","page":"Symbolic expressions","title":"Symbolic expressions","text":"Modules = [\n  GAT,\n  Syntax,\n  Rewrite,\n  Present,\n]\nPrivate = false","category":"page"},{"location":"apis/core/#Catlab.GAT","page":"Symbolic expressions","title":"Catlab.GAT","text":"Generalized algebraic theories (GATs) in Julia.\n\nAt present, this module only supports defining the signature of a GAT. In the future we may allow axioms to be expressed as well. Regardless, we will persist in calling this module \"GAT\". Signatures are defined using the @signature macro.\n\n\n\n\n\n","category":"module"},{"location":"apis/core/#Catlab.GAT.invoke_term-Tuple{Module,Tuple,Symbol,Vararg{Any,N} where N}","page":"Symbolic expressions","title":"Catlab.GAT.invoke_term","text":"Invoke a term constructor by name on an instance.\n\nThis method provides reflection for GAT signatures. In everyday use the generic method for the constructor should be called directly, not through this function.\n\nCf. Julia's builtin invoke() function.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.GAT.@instance-Tuple{Any,Any}","page":"Symbolic expressions","title":"Catlab.GAT.@instance","text":"Define an instance of a generalized algebraic theory (GAT).\n\nThese are perfectly analagous to instances of a type class in Haskell. See also the Typeclass.jl library for Julia.\n\n\n\n\n\n","category":"macro"},{"location":"apis/core/#Catlab.GAT.@signature-Tuple{Any,Any}","page":"Symbolic expressions","title":"Catlab.GAT.@signature","text":"Define a signature of a generalized algebraic theory (GAT).\n\nThree kinds of things can go in the signature body:\n\nType constructors, indicated by the special type TYPE, e.g. Hom(X::Ob,Y::Ob)::TYPE\nTerm constructors, e.g., id(X::Ob)::Hom(X,X)\nJulia functions operating on the term constructors to provide additional functionality\n\nA signature can extend existing signatures (at present only one).\n\n\n\n\n\n","category":"macro"},{"location":"apis/core/#Catlab.Syntax","page":"Symbolic expressions","title":"Catlab.Syntax","text":"Syntax systems for generalized algebraic theories (GATs).\n\nIn general, a single theory may have many different syntaxes. The purpose of this module to enable the simple but flexible construction of syntax systems.\n\n\n\n\n\n","category":"module"},{"location":"apis/core/#Catlab.Syntax.GATExpr","page":"Symbolic expressions","title":"Catlab.Syntax.GATExpr","text":"Base type for expression in the syntax of a GAT.\n\nWe define Julia types for each type constructor in the theory, e.g., object, morphism, and 2-morphism in the theory of 2-categories. Of course, Julia's type system does not support dependent types, so the type parameters are incorporated in the Julia types. (They are stored as extra data in the expression instances.)\n\nThe concrete types are structurally similar to the core type Expr in Julia. However, the term constructor is represented as a type parameter, rather than as a head field. This makes dispatch using Julia's type system more convenient.\n\n\n\n\n\n","category":"type"},{"location":"apis/core/#Base.Meta.show_sexpr-Tuple{GATExpr}","page":"Symbolic expressions","title":"Base.Meta.show_sexpr","text":"Show the syntax expression as an S-expression.\n\nCf. the standard library function Meta.show_sexpr.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.GAT.invoke_term-Tuple{Module,Symbol,Vararg{Any,N} where N}","page":"Symbolic expressions","title":"Catlab.GAT.invoke_term","text":"Invoke a term constructor by name in a syntax system.\n\nThis method provides reflection for syntax systems. In everyday use the generic method for the constructor should be called directly, not through this function.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Syntax.functor-Tuple{Tuple,GATExpr}","page":"Symbolic expressions","title":"Catlab.Syntax.functor","text":"Functor from GAT expression to GAT instance.\n\nStrictly speaking, we should call these \"structure-preserving functors\" or, better, \"model homomorphisms of GATs\". But this is a category theory library, so we'll go with the simpler \"functor\".\n\nA functor is completely determined by its action on the generators. There are several ways to specify this mapping:\n\nSimply specify a Julia instance type for each doctrine type, using the required types tuple. For this to work, the generator constructors must be defined for the instance types.\nExplicitly map each generator term to an instance value, using the generators dictionary.\n\nFor each doctrine type (e.g., object and morphism), specify a function mapping generator terms of that type to an instance value, using the terms dictionary.\n\nThe terms dictionary can also be used for special handling of non-generator expressions. One use case for this capability is defining forgetful functors, which map non-generators to generators.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Syntax.parse_json_sexpr-Tuple{Module,Any}","page":"Symbolic expressions","title":"Catlab.Syntax.parse_json_sexpr","text":"Deserialize expression from JSON-able S-expression.\n\nIf symbols is true (the default), strings are converted to symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Syntax.show_latex-Tuple{GATExpr}","page":"Symbolic expressions","title":"Catlab.Syntax.show_latex","text":"Show the expression in infix notation using LaTeX math.\n\nDoes not include $ or \\[begin|end]{equation} delimiters.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Syntax.show_unicode-Tuple{GATExpr}","page":"Symbolic expressions","title":"Catlab.Syntax.show_unicode","text":"Show the expression in infix notation using Unicode symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Syntax.to_json_sexpr-Tuple{GATExpr}","page":"Symbolic expressions","title":"Catlab.Syntax.to_json_sexpr","text":"Serialize expression as JSON-able S-expression.\n\nThe format is an S-expression encoded as JSON, e.g., \"compose(f,g)\" is represented as [\"compose\", f, g].\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Syntax.@syntax","page":"Symbolic expressions","title":"Catlab.Syntax.@syntax","text":"Define a syntax system for a generalized algebraic theory (GAT).\n\nA syntax system consists of Julia types (with top type GATExpr) for each type constructor in the signature, plus Julia functions for\n\nGenerators: creating new generator terms, e.g., objects or morphisms\nAccessors: accessing type parameters, e.g., domains and codomains\nTerm constructors: applying term constructors, e.g., composition and monoidal products\n\nJulia code for all this is generated by the macro. Any of the methods can be overriden with custom simplification logic.\n\n\n\n\n\n","category":"macro"},{"location":"apis/core/#Catlab.Rewrite","page":"Symbolic expressions","title":"Catlab.Rewrite","text":"Rewriting for GAT expressions.\n\nThe current content of this module is just a stopgap until I can implement a generic term rewriting system.\n\n\n\n\n\n","category":"module"},{"location":"apis/core/#Catlab.Rewrite.associate-Union{Tuple{E}, Tuple{E}} where E<:GATExpr","page":"Symbolic expressions","title":"Catlab.Rewrite.associate","text":"Simplify associative binary operation.\n\nMaintains the normal form op(e1,e2,...) where e1,e2,... are expressions that are not applications of op()\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Rewrite.associate_unit-Tuple{GATExpr,Function}","page":"Symbolic expressions","title":"Catlab.Rewrite.associate_unit","text":"Simplify associative binary operation with unit.\n\nReduces a freely generated (typed) monoid to normal form.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Rewrite.distribute_unary-Tuple{GATExpr,Function,Function}","page":"Symbolic expressions","title":"Catlab.Rewrite.distribute_unary","text":"Distribute unary operation over binary operation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Rewrite.involute-Tuple{GATExpr}","page":"Symbolic expressions","title":"Catlab.Rewrite.involute","text":"Simplify involutive unary operation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present","page":"Symbolic expressions","title":"Catlab.Present","text":"Finite presentations of a model of a generalized algebraic theory (GAT).\n\nWe support two methods for defining models of a GAT: as Julia objects using the @instance macro and as syntactic objects using the @present macro. Instances are useful for casting generic data structures, such as matrices, abstract tensor systems, and wiring diagrams, in categorical language. Presentations define small categories by generators and relations and are useful in applications like knowledge representation.\n\n\n\n\n\n","category":"module"},{"location":"apis/core/#Catlab.Present.add_definition!-Tuple{Presentation,Symbol,GATExpr}","page":"Symbolic expressions","title":"Catlab.Present.add_definition!","text":"Add a generator defined by an equation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.add_equation!-Tuple{Presentation,GATExpr,GATExpr}","page":"Symbolic expressions","title":"Catlab.Present.add_equation!","text":"Add an equation between terms to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.add_generator!-Union{Tuple{T}, Tuple{Presentation{T},GATExpr{:generator}}} where T","page":"Symbolic expressions","title":"Catlab.Present.add_generator!","text":"Add a generator to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.add_generators!-Tuple{Presentation,Any}","page":"Symbolic expressions","title":"Catlab.Present.add_generators!","text":"Add multiple generators to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.equations-Tuple{Presentation}","page":"Symbolic expressions","title":"Catlab.Present.equations","text":"Get all equations of a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.generator-Union{Tuple{T}, Tuple{Presentation{T},Any}} where T","page":"Symbolic expressions","title":"Catlab.Present.generator","text":"Retrieve generators by name.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.generators-Tuple{Presentation}","page":"Symbolic expressions","title":"Catlab.Present.generators","text":"Get all generators of a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.has_generator-Union{Tuple{T}, Tuple{Presentation{T},Any}} where T","page":"Symbolic expressions","title":"Catlab.Present.has_generator","text":"Does the presentation contain a generator with the given name?\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.merge_presentation!-Union{Tuple{T}, Tuple{Presentation{T},Presentation{T}}} where T","page":"Symbolic expressions","title":"Catlab.Present.merge_presentation!","text":"Merge the second presentation into the first.\n\nThe first presentation is mutated and returned; the second is not.\n\n\n\n\n\n","category":"method"},{"location":"apis/core/#Catlab.Present.@present-Tuple{Any,Any}","page":"Symbolic expressions","title":"Catlab.Present.@present","text":"Define a presentation using a convenient syntax.\n\n\n\n\n\n","category":"macro"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"EditURL = \"https://github.com/epatters/Catlab.jl/blob/master/docs/literate/graphics/graphviz_wiring_diagrams.jl\"","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Wiring-diagrams-in-Graphviz-1","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"(Image: )","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"Catlab can draw wiring diagrams using the dot program in Graphviz. This feature requires that Graphviz be installed, but does not require any additional Julia packages.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"using Catlab.WiringDiagrams, Catlab.Graphics","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Examples-1","page":"Wiring diagrams in Graphviz","title":"Examples","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Symmetric-monoidal-category-1","page":"Wiring diagrams in Graphviz","title":"Symmetric monoidal category","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"using Catlab.Doctrines\n\nA, B = Ob(FreeSymmetricMonoidalCategory, :A, :B)\nf = Hom(:f, A, B)\ng = Hom(:g, B, A)\nh = Hom(:h, otimes(A,B), otimes(A,B));\nnothing #hide","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"To start, here are a few very simple examples.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(f)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(compose(f,g))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(otimes(f,g))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"In the next example, notice how Graphviz automatically \"untwists\" the double braiding to minimize edge crossings.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(compose(braid(A,A), otimes(f,f), braid(B,B)))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"Here is a larger composite morphism.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"composite = compose(otimes(g,f), h, otimes(f,g))\nto_graphviz(composite)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"By default, the wiring diagram is laid out from top to bottom. Other layout orientations can be requested, such as left-to-right or bottom-to-top:","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(composite, orientation=LeftToRight)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(composite, orientation=BottomToTop)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"When working with very large diagrams (larger than the ones shown here), it is sometimes convenient to omit the ports of the outer box and any wires attached to them.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(composite, outer_ports=false)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Biproduct-category-1","page":"Wiring diagrams in Graphviz","title":"Biproduct category","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"A, B = Ob(FreeBiproductCategory, :A, :B)\nf = Hom(:f, A, B)\ng = Hom(:g, B, A);\nnothing #hide","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"By default, copies and merges are drawn the way they are represented internally, as multiple wires.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"f1 = compose(mcopy(A), otimes(f,f))\nto_graphviz(f1)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"f2 = compose(mcopy(A), otimes(f,f), mmerge(B))\nto_graphviz(f2)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"To draw nodes for copies and merges, we need to add junctions to the wiring diagram.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(add_junctions!(to_wiring_diagram(f1)))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(add_junctions!(to_wiring_diagram(f2)))","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Custom-styles-1","page":"Wiring diagrams in Graphviz","title":"Custom styles","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"The visual appearance of wiring diagrams can be customized by setting Graphviz attributes at the graph, node, edge, and cell levels. Graph, node, and edge attributes are described in the Graphviz documentation. Cell attributes are passed to the primary cell of the HTML-like label used for the boxes.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"to_graphviz(compose(f,g),\n  labels = true, label_attr=:headlabel,\n  node_attrs = Dict(\n    :fontname => \"Courier\",\n  ),\n  edge_attrs = Dict(\n    :fontname => \"Courier\",\n    :labelangle => \"25\",\n    :labeldistance => \"2\",\n  ),\n  cell_attrs = Dict(\n    :bgcolor => \"lavender\",\n  )\n)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#Output-formats-1","page":"Wiring diagrams in Graphviz","title":"Output formats","text":"","category":"section"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"The function to_graphviz returns an object of a type Graphviz.Graph, representing a Graphviz graph as an abstract syntax tree. When displayed interactively, this object is automatically run through Graphviz and rendered as an SVG image. Sometimes it is convenient to perform this process manually, to change the output format or further customize the generated dot file.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"To generate a dot file, use the builtin pretty-printer. This feature does not require Graphviz to be installed.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"using Catlab.Graphics: Graphviz\n\ngraph = to_graphviz(compose(f,g))\nGraphviz.pprint(graph)","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"Catlab provides a simple wrapper around the Graphviz command-line programs. For example, here the JSON output for the graph.","category":"page"},{"location":"generated/graphics/graphviz_wiring_diagrams/#","page":"Wiring diagrams in Graphviz","title":"Wiring diagrams in Graphviz","text":"import JSON\n\nJSON.parse(Graphviz.run_graphviz(graph, format=\"json0\"))","category":"page"},{"location":"apis/graphics/#Graphics-1","page":"Graphics","title":"Graphics","text":"","category":"section"},{"location":"apis/graphics/#","page":"Graphics","title":"Graphics","text":"CurrentModule = Catlab.Graphics","category":"page"},{"location":"apis/graphics/#","page":"Graphics","title":"Graphics","text":"Modules = [\n  Graphviz,\n  GraphvizWiringDiagrams,\n  TikZ,\n  TikZWiringDiagrams,\n  YFilesWiringDiagrams,\n]\nPrivate = false","category":"page"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz","page":"Graphics","title":"Catlab.Graphics.Graphviz","text":"AST and pretty printer for Graphviz's DOT language.\n\nReferences:\n\nDOT grammar: http://www.graphviz.org/doc/info/lang.html\nDOT language guide: http://www.graphviz.org/pdf/dotguide.pdf\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.pprint-Tuple{Catlab.Graphics.Graphviz.Expression}","page":"Graphics","title":"Catlab.Graphics.Graphviz.pprint","text":"Pretty-print the Graphviz expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.run_graphviz-Tuple{Catlab.Graphics.Graphviz.Graph}","page":"Graphics","title":"Catlab.Graphics.Graphviz.run_graphviz","text":"Run a Graphviz program.\n\nAssumes that Graphviz is installed on the local system and invokes Graphviz through its command-line interface.\n\nFor bindings to the Graphviz C API, see the the GraphViz.jl package (https://github.com/Keno/GraphViz.jl). GraphViz.jl is unmaintained at the time of this writing.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.to_graphviz-Tuple{MetaGraphs.AbstractMetaGraph}","page":"Graphics","title":"Catlab.Graphics.Graphviz.to_graphviz","text":"Convert an attributed graph (MetaGraph) to a Graphviz graph.\n\nThis method is usually more convenient than direct AST manipulation for creating Graphviz graphs. It supports graphs that are directed or undirected, simple or multi-edged. For more advanced features, like nested subgraphs, you must use the Graphviz AST directly.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams","page":"Graphics","title":"Catlab.Graphics.GraphvizWiringDiagrams","text":"Draw wiring diagrams using Graphviz.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.to_graphviz-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Graphics","title":"Catlab.Graphics.Graphviz.to_graphviz","text":"Draw a wiring diagram using Graphviz.\n\nThe input f can also be a morphism expression, which is converted into a wiring diagram.\n\nArguments\n\ngraph_name=\"G\": name of Graphviz digraph\norientation=TopToBottom: orientation of layout. One of LeftToRight, RightToLeft, TopToBottom, or BottomToTop.\nnode_labels=true: whether to label the nodes\nlabels=false: whether to label the edges\nlabel_attr=:label: what kind of edge label to use (if labels is true). One of :label, :xlabel, :headlabel, or :taillabel.\nport_size=\"24\": minimum size of ports on box, in points\njunction_size=\"0.05\": size of junction nodes, in inches\nouter_ports=true: whether to display the outer box's input and output ports. If disabled, no incoming or outgoing wires will be shown either!\nanchor_outer_ports=true: whether to enforce ordering of the outer box's input and output, i.e., ordering of the incoming and outgoing wires\ngraph_attrs=default_graph_attrs: top-level graph attributes\nnode_attrs=default_node_attrs: top-level node attributes\nedge_attrs=default_edge_attrs: top-level edge attributes\ncell_attrs=default_cell_attrs: main cell attributes in node HTML-like label\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZ","page":"Graphics","title":"Catlab.Graphics.TikZ","text":"AST and pretty printer for TikZ.\n\nThis module does not provide bindings to the TikZ LaTeX package. For that, see the TikzPictures.jl package: https://github.com/sisl/TikzPictures.jl\n\nThe AST is large but still incomplete! It supports:\n\nNodes (\\node) and edges (\\draw)\nNodes along edges (\\draw ... node ...)\nGraphs (\\graph)\nMatrices (\\matrix)\nScopes and nested pictures\n\nThe AST is adapted from the (also incomplete) BNF grammar for TikZ in TikZit.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.TikZ.pprint-Tuple{Catlab.Graphics.TikZ.Expression}","page":"Graphics","title":"Catlab.Graphics.TikZ.pprint","text":"Pretty-print the TikZ expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams","page":"Graphics","title":"Catlab.Graphics.TikZWiringDiagrams","text":"Draw wiring diagrams using TikZ.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.layout_to_tikz-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Graphics","title":"Catlab.Graphics.TikZWiringDiagrams.layout_to_tikz","text":"Draw a wiring diagram in TikZ using the given layout.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.to_tikz-Tuple","page":"Graphics","title":"Catlab.Graphics.TikZWiringDiagrams.to_tikz","text":"Draw a wiring diagram in TikZ.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.YFilesWiringDiagrams","page":"Graphics","title":"Catlab.Graphics.YFilesWiringDiagrams","text":"Deserialize abstract wiring diagram from yFiles.\n\nReads a wiring diagram from the GraphML dialect used by yEd and yFiles. Unlike the GraphML spec, the yEd data model does not explicitly include ports:\n\nhttps://yed.yworks.com/support/qa/102/\nhttps://yed.yworks.com/support/qa/2531/\n\nWe infer the ports of boxes and their order from the geometry of the diagram. Thus, this module has the nature of a hack. While it may be useful for interactive and exploratory work, it should not be used in a production system.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.YFilesWiringDiagrams.parse_yfiles_diagram-Tuple{Type,Type,AbstractString}","page":"Graphics","title":"Catlab.Graphics.YFilesWiringDiagrams.parse_yfiles_diagram","text":"Parse a wiring diagram from a GraphML string or XML doc created by yFiles.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.YFilesWiringDiagrams.read_yfiles_diagram-Tuple{Type,Type,String}","page":"Graphics","title":"Catlab.Graphics.YFilesWiringDiagrams.read_yfiles_diagram","text":"Read a wiring diagram from a GraphML file created by yEd and yFiles.\n\n\n\n\n\n","category":"method"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"EditURL = \"https://github.com/epatters/Catlab.jl/blob/master/docs/literate/wiring_diagrams/diagrams_and_expressions.jl\"","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#Wiring-diagrams-and-syntactic-expressions-1","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"","category":"section"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"(Image: )","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Morphisms in a monoidal category can be represented as syntactic expressions, such as f cdot g and f otimes g, and also as wiring diagrams, aka string diagrams. Catlab provides facilities for transforming between these two representations.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"using Catlab.Doctrines, Catlab.WiringDiagrams\nusing Catlab.Graphics\n\nfunction show_diagram(d::WiringDiagram)\n  to_graphviz(d, orientation=LeftToRight, labels=false)\nend","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#Expressions-to-diagrams-1","page":"Wiring diagrams and syntactic expressions","title":"Expressions to diagrams","text":"","category":"section"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Converting a morphism expression to a wiring diagram is conceptually and algorithmically simple, because every expression determines a unique diagram.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"As a simple example, here is the monoidal product of two generators, f and g, first as an expression (displayed using LaTeX) and then as a wiring diagram (displayed using Graphviz).","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"A, B, C, D, E = Ob(FreeCartesianCategory, :A, :B, :C, :D, :E)\nf = Hom(:f, A, B)\ng = Hom(:g, B, C)\n\nexpr = f ⊗ g","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"show_diagram(to_wiring_diagram(expr))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Here is a monoidal product of compositions:","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"h = Hom(:h, C, D)\nk = Hom(:k, D, E)\n\nexpr = (f ⋅ g) ⊗ (h ⋅ k)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"show_diagram(to_wiring_diagram(expr))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#Diagrams-to-expressions-1","page":"Wiring diagrams and syntactic expressions","title":"Diagrams to expressions","text":"","category":"section"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Converting a wiring diagram to a syntactic expression is algorithmically more challenging, due to the fact that a single wiring diagram generally admits many different representations as an expression. Thus, a particular expression must be singled out.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"To bring this out, we define a function that round-trips a morphism expression to a wiring diagram and then back to an expression.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"function roundtrip_expr(expr::FreeCartesianCategory.Hom)\n  d = to_wiring_diagram(expr)\n  to_hom_expr(FreeCartesianCategory, d)\nend","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"We can recover the expression just considered above:","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr((f ⋅ g) ⊗ (h ⋅ k))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"But here is a different expression that round-trips to the same thing:","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr((f ⊗ h) ⋅ (g ⊗ k))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"The equality of these two expressions,","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"(f cdot g) otimes (h cdot k) = (f otimes h) cdot (g otimes k)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"is the interchange law in a monoidal category. It says that composition and monoidal products can be interchanged. As this example shows, the conversion algorithm in Catlab favors products over composition, placing products towards the root of the expression tree wherever possible. Other laws can be discovered by this procedure. Since we are working in a cartesian monoidal category, operations of copying, Delta_A A to A otimes A, and deleting, lozenge_A A to I, are available.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Consider the operation of copying the product A otimes B.","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"expr = mcopy(A ⊗ B)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"show_diagram(add_junctions!(to_wiring_diagram(expr)))","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr(expr)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"The equation just witnessed,","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"Delta_A otimes B = (Delta_A otimes Delta_B) cdot (1_A otimes sigma_AB otimes 1_B)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"is one of the coherence laws for cartesian products (arXiv:0908.3347, Table 7). Another coherence law for products is","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"lozenge_A otimes B = lozenge_A otimes lozenge_B","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"expr = delete(A ⊗ B)","category":"page"},{"location":"generated/wiring_diagrams/diagrams_and_expressions/#","page":"Wiring diagrams and syntactic expressions","title":"Wiring diagrams and syntactic expressions","text":"roundtrip_expr(expr)","category":"page"},{"location":"apis/wiring_diagrams/#Wiring-diagrams-1","page":"Wiring diagrams","title":"Wiring diagrams","text":"","category":"section"},{"location":"apis/wiring_diagrams/#","page":"Wiring diagrams","title":"Wiring diagrams","text":"CurrentModule = Catlab.WiringDiagrams","category":"page"},{"location":"apis/wiring_diagrams/#","page":"Wiring diagrams","title":"Wiring diagrams","text":"Modules = [\n  WiringDiagramCore,\n  WiringLayers,\n  AlgebraicWiringDiagrams,\n  WiringDiagramAlgorithms,\n  WiringDiagramSerialization,\n  GraphMLWiringDiagrams,\n  JSONWiringDiagrams,\n]\nPrivate = false","category":"page"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore","text":"Generic data structures for wiring diagrams (aka, string diagrams).\n\nA (directed) wiring diagram consists of a collection of boxes with input and output ports connected by wires. A box can be atomic (possessing no internal structure) or can itself be a wiring diagram. Thus, wiring diagrams can be nested recursively. Wiring diagrams are closely related to what the CS literature calls \"directed graphs with ports\" or more simply \"port graphs\". The main difference is that a wiring diagram has an \"outer box\": a wiring diagram has its own ports that can be connected to the ports of its boxes.\n\nThis module provides a generic data structure for wiring diagrams. Arbitrary data can be attached to the boxes, ports, and wires of a wiring diagram. The diagrams are \"abstract\" in the sense that they cannot be directly rendered as raster or vector graphics. However, they form a useful intermediate representation that can be serialized to and from GraphML or translated into Graphviz or other declarative diagram languages.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.AbstractBox","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.AbstractBox","text":"Base type for any box (node) in a wiring diagram.\n\nThis type represents an arbitrary black box with inputs and outputs.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Box","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.Box","text":"An atomic box in a wiring diagram.\n\nThese boxes have no internal structure.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Port","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.Port","text":"A port on a box to which wires can be connected.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.PortKind","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.PortKind","text":"Kind of port: input or output.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Wire","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.Wire","text":"A wire connecting one port to another.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram","text":"A directed wiring diagram, aka a string diagram.\n\nThe wiring diagram is implemented using the following internal data structures. A LightGraphs DiGraph stores the \"skeleton\" of the diagram: a simple directed graph with the boxes as vertices and with an edge between two vertices iff there is at least one wire between the corresponding boxes. There are two special vertices, accessible via input_id and output_id, representing the input and output ports, respectively.\n\nThe DiGraph is wrapped inside a MetaDiGraph to attach properties to the vertices and edges. For each edge, an edge property stores the list of wires between the source and target boxes.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.encapsulate-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.encapsulate","text":"Encapsulate multiple boxes within a single sub-diagram.\n\nThis operation is a (one-sided) inverse to subsitution (see substitute).\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.encapsulated_subdiagram-Union{Tuple{T}, Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram{T},Array{Int64,1}}} where T","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.encapsulated_subdiagram","text":"Create an encapsulating box for a set of boxes in a wiring diagram.\n\nTo a first approximation, the union of input ports of the given boxes will become the inputs ports of the encapsulating box and likewise for the output ports. However, when copies or merges occur, as in a cartesian or cocartesian category, a simplification procedure may reduce the number of ports on the encapsulating box.\n\nSpecifically:\n\nEach input port of an encapsulated box will have at most one incoming wire\n\nfrom the encapsulating outer box, and each output port of an encapsulated box will have at most one outgoing wire to the encapsulating outer box.\n\nA set of ports connected to the same outside (non-encapsulated) ports will be\n\nsimplified into a single port of the encapsulating box.\n\nSee also induced_subdiagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.graph-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.graph","text":"Retrieve the underlying LightGraphs graph.\n\nDo not mutate it! All mutations should pass through the WiringDiagram methods: add_box!, rem_box!, etc.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.in_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Catlab.WiringDiagrams.WiringDiagramCore.Port}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.in_wires","text":"Get all wires coming into the port.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.in_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.in_wires","text":"Get all wires coming into the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.induced_subdiagram-Union{Tuple{T}, Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram{T},Array{Int64,1}}} where T","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.induced_subdiagram","text":"The wiring diagram induced by a subset of its boxes.\n\nSee also encapsulated_subdiagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.is_permuted_equal-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.is_permuted_equal","text":"Check equality of wiring diagram under permutation of boxes.\n\nWhen the boxes in the first diagram d1 are permuted according to σ, does it become identical to the second diagram d2?\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.out_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Catlab.WiringDiagrams.WiringDiagramCore.Port}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.out_wires","text":"Get all wires coming out of the port.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.out_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.out_wires","text":"Get all wires coming out of the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.singleton_diagram-Tuple{Type,Catlab.WiringDiagrams.WiringDiagramCore.AbstractBox}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.singleton_diagram","text":"A wiring diagram with a single box connected to its outer ports.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.substitute-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.substitute","text":"Substitute wiring diagrams for boxes.\n\nPerforms one or more substitutions. When performing multiple substitutions, the substitutions are simultaneous.\n\nThis operation implements the operadic composition of wiring diagrams (ocompose).\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.validate_ports-Tuple{Any,Any}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.validate_ports","text":"Check compatibility of source and target ports.\n\nThe default implementation is a no-op.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramCore.wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramCore.wires","text":"Get all wires coming into or out of the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringLayers","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringLayers","text":"Data structure for connecting one layer to another by wires.\n\nThis module defines a generic data structure to represent a wiring between one layer of input ports and another layer of output ports. A wiring layer forms a bipartite graph with independent edge sets the input ports and the output ports.\n\nWiring layers are an auxillary data structure. They are not very interesting in their own right, but they can be a useful intermediate representation. For example, a morphism expression comprising generators, compositions, products, and wiring layers is intermediate between a pure GAT expression (which has no wiring layers, but may have identities, braidings, copies, etc.) and a wiring diagram, which is purely graphical.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringLayers.NLayer","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringLayers.NLayer","text":"Number of input or output ports in a layer.\n\nObject in the category of wiring layers.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringLayers.WiringLayer","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringLayers.WiringLayer","text":"Connection by wires of one layer to another.\n\nMorphism in the category of wiring layers.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringLayers.complete_layer-Tuple{Int64,Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringLayers.complete_layer","text":"Completely connected wiring layer.\n\nThe layer's underlying graph is the complete bipartite graph.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringLayers.to_wiring_diagram-Tuple{Catlab.WiringDiagrams.WiringLayers.WiringLayer,Array{T,1} where T,Array{T,1} where T}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringLayers.to_wiring_diagram","text":"Convert a wiring layer into a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringLayers.wiring_layer_between-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64,Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringLayers.wiring_layer_between","text":"Wiring layer representing the wires between two boxes in a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams","text":"Wiring diagrams as a symmetric monoidal category and as an operad.\n\nThis module provides a high-level functional and algebraic interface to wiring diagrams, building on the low-level imperative interface. It also defines data types and functions to represent diagonals, codiagonals, duals, caps, cups, daggers, and other structures in wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.BoxOp","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.BoxOp","text":"Box wrapping another box.\n\nRepresents unary operations on boxes in wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.Junction","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.Junction","text":"Junction node in a wiring diagram.\n\nJunction nodes are used to explicitly represent copies, merges, deletions, creations, caps, and cups.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.PortOp","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.PortOp","text":"Port value wrapping another value.\n\nRepresents unary operations on ports in wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.Ports","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.Ports","text":"A list of ports.\n\nThe objects in categories of wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiring_diagrams/#Catlab.Syntax.functor-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Any,Any}","page":"Wiring diagrams","title":"Catlab.Syntax.functor","text":"Apply functor in a category of wiring diagrams.\n\nDefined by compatible mappings of ports and boxes.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.add_junctions-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.add_junctions","text":"Add junction nodes to wiring diagram.\n\nTransforms from the implicit to the explicit representation of diagonals and codiagonals. This operation is inverse to rem_junctions.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.junction_caps-Tuple{Catlab.WiringDiagrams.AlgebraicWiringDiagrams.Ports}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.junction_caps","text":"Wiring diagram of nested caps made out of junction nodes.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.junction_cups-Tuple{Catlab.WiringDiagrams.AlgebraicWiringDiagrams.Ports}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.junction_cups","text":"Wiring diagram of nested cups made out of junction nodes.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.junction_diagram-Tuple{Catlab.WiringDiagrams.AlgebraicWiringDiagrams.Ports,Int64,Int64}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.junction_diagram","text":"Wiring diagram with a junction node for each of the given ports.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.merge_junctions-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.merge_junctions","text":"Merge adjacent junction nodes into single junctions.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.ocompose-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{#s87,1} where #s87<:Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.ocompose","text":"Operadic composition of wiring diagrams.\n\nThis generic function has two different signatures, corresponding to the two standard definitions of an operad (Yau, 2018, Operads of Wiring Diagrams, Definitions 2.3 and 2.10).\n\nThis operation is a simple wrapper around substitution (substitute).\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.AlgebraicWiringDiagrams.rem_junctions-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.AlgebraicWiringDiagrams.rem_junctions","text":"Remove junction nodes from wiring diagram.\n\nTransforms from the explicit to the implicit representation of diagonals and codiagonals. This operation is inverse to add_junctions.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms","text":"Algorithms operating on wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.crossing_minimization_by_sort-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.crossing_minimization_by_sort","text":"Crossing minimization by sorting a univariate statistic.\n\nThe boxes in sources and/or targets are fixed and the boxes in vs are permuted. A permutation σ of the latter is returned, such that vs[σ] are the sorted box IDs. Both one-sided and two-sided crossing minimization are supported, depending on whether just one, or both, of sources and targets are given.\n\nIn this simple but popular heuristic algorithm, the boxes are permuted by sorting a univariate statistic of the positions of incoming and/or outgoing wires. Typical choices are:\n\nmean: the sample mean, yielding the \"barycenter method\"\nmedian: the sample median\n\nIn both cases, this algorithm has the property that if there is a permutation with no crossings, it will find it.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_cartesian!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_cartesian!","text":"Put a wiring diagram for a cartesian category into normal form.\n\nThis function puts a wiring diagram representing a morphism in a free cartesian category into normal form. Copies and deletions are simplified as much as possible.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_copy!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_copy!","text":"Normalize copies in a wiring diagram.\n\nThis function maximizes sharing of intermediate computations in a wiring diagram where copies are natural.\n\nThis algorithm is basically the same as the congruence closure algorithm on term graphs, in the special case of the empty relation R = ∅ (Baader & Nipkow, 1998, Term Rewriting and All That, Sec. 4.4). The main difference is the possibility of zero or many function outputs.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_delete!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_delete!","text":"Normalize deletions in a wiring diagram.\n\nThis function removes all unused intermediate computations in a wiring diagram where deletion is natural.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.topological_sort-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.topological_sort","text":"Topological sort of boxes in wiring diagram.\n\nReturns a list of box IDs, excluding the outer box's input and output IDs.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.WiringDiagramSerialization","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.WiringDiagramSerialization","text":"Conventions for serialization of wiring diagrams.\n\nDefines a consistent set of names for boxes, ports, and wires to be used when serializing wiring diagrams, as well as conventions for serializing box, port, and wire attributes.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams","text":"Serialize abstract wiring diagrams as GraphML.\n\nSerialization of box, port, and wire values can be overloaded by data type (see convert_to_graphml_data and convert_from_graphml_data).\n\nGraphML is the closest thing to a de jure and de facto standard in the space of graph data formats, supported by a variety of graph applications and libraries. We depart mildly from the GraphML spec by allowing JSON data attributes for GraphML nodes, ports, and edges.\n\nReferences:\n\nGraphML Primer: http://graphml.graphdrawing.org/primer/graphml-primer.html\nGraphML DTD: http://graphml.graphdrawing.org/specification/dtd.html\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.generate_graphml-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.generate_graphml","text":"Generate GraphML representing a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml-Tuple{Type,Type,Type,AbstractString}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml","text":"Parse a wiring diagram from a GraphML string or XML document.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml-Tuple{Type,Type,Type,String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml","text":"Read a wiring diagram from a GraphML file.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.write_graphml-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.write_graphml","text":"Write a wiring diagram to a file as GraphML.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams","text":"Serialize abstract wiring diagrams as JSON.\n\nJSON data formats are convenient when programming for the web. Unfortunately, no standard for JSON graph formats has gained any kind of widespread adoption. We adopt a format compatible with that used by the KEILER project and its successor ELK (Eclipse Layout Kernel). This format is roughly feature compatible with GraphML, supporting nested graphs and ports. It also supports layout information like node position and size.\n\nReferences:\n\nKEILER's JSON graph format: https://rtsys.informatik.uni-kiel.de/confluence/display/KIELER/JSON+Graph+Format\nELK's JSON graph format: https://www.eclipse.org/elk/documentation/tooldevelopers/graphdatastructure/jsonformat.html\n\n\n\n\n\n","category":"module"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.generate_json_graph-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.generate_json_graph","text":"Generate a JSON dict representing a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.parse_json_graph-Tuple{Type,Type,Type,Union{AbstractString, IO}}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.parse_json_graph","text":"Parse a wiring diagram from a JSON string or dict.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.read_json_graph-Tuple{Type,Type,Type,String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.read_json_graph","text":"Read a wiring diagram from a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiring_diagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.write_json_graph-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,String}","page":"Wiring diagrams","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.write_json_graph","text":"Write a wiring diagram to a file as JSON.\n\n\n\n\n\n","category":"method"},{"location":"#Catlab.jl-Documentation-1","page":"Catlab.jl","title":"Catlab.jl Documentation","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"CurrentModule = Catlab","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab.jl is an experimental framework for applied category theory, written in Julia. It provides a programming library and interactive interface for applications of category theory to the sciences and engineering fields. It emphasizes monoidal categories due to their wide applicability but can support any categorical doctrine that is formalizable as a generalized algebraic theory.","category":"page"},{"location":"#What-is-Catlab?-1","page":"Catlab.jl","title":"What is Catlab?","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab is, or will eventually be, the following things.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Programming library: First and foremost, Catlab provides data structures, algorithms, and serialization for applied category theory. Macros offer a convenient syntax for specifying categorical doctrines and type-safe symbolic manipulation systems. Wiring diagrams (aka string diagrams) are supported through specialized data structures and can be serialized to and from GraphML (an XML-based format) and JSON.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Interactive computing environment: Catlab can also be used interactively in Jupyter notebooks. Symbolic expressions are displayed using LaTeX and wiring diagrams are visualized using Graphviz or TikZ.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Computer algebra system: Catlab will serve as a computer algebra system for category theory. Unlike most computer algebra systems, all expressions are typed using fragment of dependent type theory called generalized algebraic theories. We will implement core algorithms for solving word problems and reducing expressions in normal form, with respect to several important doctrines, such as the doctrine of categories and the doctrine of symmetric monoidal categories.","category":"page"},{"location":"#What-is-Catlab-not?-1","page":"Catlab.jl","title":"What is Catlab not?","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab is not currently any of the following things, although we do not rule out that it could eventually evolve in these directions.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Automated theorem prover: Although there is some overlap between computer algebra systems and automated theorem provers, Catlab cannot be considered a theorem prover because it does not produce formal certificates of correctness (aka proofs).","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Proof assistant: Likewise, Catlab is not a proof assistant because it does not produce formally verifiable proofs. Formal verification is not within scope of the project.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Graphical user interface: Catlab does not provide a wiring diagram editor or other graphical user interface. It is primarily a programming library, not a user-facing application. However, it could be used as the backend for such an application.","category":"page"},{"location":"#Table-of-Contents-1","page":"Catlab.jl","title":"Table of Contents","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Pages = [\n     \"apis/core.md\",\n     \"apis/doctrines.md\",\n     \"apis/wiring_diagrams.md\",\n     \"apis/graphics.md\",\n     \"apis/programs.md\",\n     ]\nDepth = 2","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"EditURL = \"https://github.com/epatters/Catlab.jl/blob/master/docs/literate/graphics/composejl_wiring_diagrams.jl\"","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Wiring-diagrams-in-Compose.jl-1","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"(Image: )","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"Catlab can draw wiring diagrams using the Julia package Compose.jl.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"using Catlab.WiringDiagrams, Catlab.Graphics","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Examples-1","page":"Wiring diagrams in Compose.jl","title":"Examples","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#Symmetric-monoidal-category-1","page":"Wiring diagrams in Compose.jl","title":"Symmetric monoidal category","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"using Catlab.Doctrines\n\nA, B, C, D = Ob(FreeSymmetricMonoidalCategory, :A, :B, :C, :D)\nf, g = Hom(:f, A, B), Hom(:g, B, A);\nnothing #hide","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"To start, here are a few very simple examples.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(f)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(f⋅g)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(f⊗g)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"Here is a more complex example, involving generators with compound domains and codomains.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"h, k = Hom(:h, C, D),  Hom(:k, D, C)\nm, n = Hom(:m, B⊗A, A⊗B), Hom(:n, D⊗C, C⊗D)\nq = Hom(:l, A⊗B⊗C⊗D, D⊗C⊗B⊗A)\n\nto_composejl((f⊗g⊗h⊗k)⋅(m⊗n)⋅q⋅(n⊗m)⋅(h⊗k⊗f⊗g))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"Identities and braidings appear as wires.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(id(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(braid(A,B))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(braid(A,B) ⋅ (g⊗f) ⋅ braid(A,B))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"The isomorphism A otimes B otimes C to C otimes B otimes A induced by the permutation (3 2 1) is a composite of braidings and identities.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl((braid(A,B) ⊗ id(C)) ⋅ (id(B) ⊗ braid(A,C) ⋅ (braid(B,C) ⊗ id(A))))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Biproduct-category-1","page":"Wiring diagrams in Compose.jl","title":"Biproduct category","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"A, B = Ob(FreeBiproductCategory, :A, :B)\nf = Hom(:f, A, B)\n\nto_composejl(mcopy(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(delete(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(mcopy(A)⋅(f⊗f)⋅mmerge(B))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Compact-closed-category-1","page":"Wiring diagrams in Compose.jl","title":"Compact closed category","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"The unit and co-unit of a compact closed category appear as caps and cups.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"A, B = Ob(FreeCompactClosedCategory, :A, :B)\n\nto_composejl(dunit(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl(dcounit(A))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"In a self-dual compact closed category, such as a bicategory of relations, every morphism f A to B has a transpose f^dagger B to A given by bending wires:","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"A, B = Ob(FreeBicategoryRelations, :A, :B)\nf = Hom(:f, A, B)\n\nto_composejl((dunit(A) ⊗ id(B)) ⋅ (id(A) ⊗ f ⊗ id(B)) ⋅ (id(A) ⊗ dcounit(B)))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Abelian-bicategory-of-relations-1","page":"Wiring diagrams in Compose.jl","title":"Abelian bicategory of relations","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"In an abelian bicategory of relations, such as the category of linear relations, the duplication morphisms Delta_X X to X otimes X and addition morphisms blacktriangledown_X X otimes X to X belong to a bimonoid. Among other things, this means that the following two morphisms are equal.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_composejl(mplus(X) ⋅ mcopy(X))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"to_composejl((mcopy(X)⊗mcopy(X)) ⋅ (id(X)⊗braid(X,X)⊗id(X)) ⋅ (mplus(X)⊗mplus(X)))","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Custom-styles-1","page":"Wiring diagrams in Compose.jl","title":"Custom styles","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"The visual appearance of wiring diagrams can be customized by passing Compose properties.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"using Compose: fill, stroke\n\nA, B, = Ob(FreeSymmetricMonoidalCategory, :A, :B)\nf, g = Hom(:f, A, B), Hom(:g, B, A)\n\nto_composejl(f⋅g, box_props=[fill(\"lavender\"), stroke(\"black\")])","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"X = Ob(FreeAbelianBicategoryRelations, :X)\n\nto_composejl(mplus(X) ⋅ mcopy(X),\n    junction_props=[fill(\"red\"), stroke(\"black\")],\n    junction_variant_props=[fill(\"blue\"), stroke(\"black\")],\n)","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#Output-formats-1","page":"Wiring diagrams in Compose.jl","title":"Output formats","text":"","category":"section"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"The function to_composejl returns a ComposePicture object, which contains a Compose.jl context as well as a recommended width and height. When displayed interactively, this object is rendered using Compose's SVG backend.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"Any backend can be used by calling Compose's draw function. The SVG and PGF (LaTeX) backends are always available. To use the PNG or PDF backends, the extra packages Cairo.jl and Fontconfig.jl must be installed.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"For example, here is how to use the PGF backend.","category":"page"},{"location":"generated/graphics/composejl_wiring_diagrams/#","page":"Wiring diagrams in Compose.jl","title":"Wiring diagrams in Compose.jl","text":"using Compose: draw, PGF\n\npic = to_composejl(f⋅g, rounded_boxes=false)\npgf = sprint() do io\n  pgf_backend = PGF(io, pic.width, pic.height,\n    false, # emit_on_finish\n    true,  # only_tikz\n    texfonts=true)\n  draw(pgf_backend, pic.context)\nend\nprintln(pgf)","category":"page"}]
}
