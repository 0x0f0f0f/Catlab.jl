var documenterSearchIndex = {"docs":
[{"location":"apis/algebra/#Catlab.Algebra-API-1","page":"Catlab.Algebra API","title":"Catlab.Algebra API","text":"","category":"section"},{"location":"apis/algebra/#","page":"Catlab.Algebra API","title":"Catlab.Algebra API","text":"CurrentModule = Catlab","category":"page"},{"location":"apis/algebra/#","page":"Catlab.Algebra API","title":"Catlab.Algebra API","text":"Modules = [Algebra,\n           Algebra.Network,\n           Algebra.Network.AlgebraicNet,\n           Algebra.Network.AlgebraicNetSignature,\n           Algebra.Tree,\n          ]","category":"page"},{"location":"apis/algebra/#Catlab.Algebra","page":"Catlab.Algebra API","title":"Catlab.Algebra","text":"A module for traditional computer algebra from a categorical point of view.\n\n\n\n\n\n","category":"module"},{"location":"apis/algebra/#Catlab.Algebra.Network","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network","text":"Computer algebra via monoidal categories.\n\nIn a conventional computer algebra system, algebraic expressions are represented as trees whose leaves are variables or constants and whose internal nodes are arithmetic operations or elementary or special functions. The idea here is to represent expressions as morphisms in a monoidal category.\n\n\n\n\n\n","category":"module"},{"location":"apis/algebra/#Catlab.Algebra.Network.AlgebraicNetSignature","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.AlgebraicNetSignature","text":"Doctrine of algebraic networks\n\nTODO: Explain\n\n\n\n\n\n","category":"module"},{"location":"apis/algebra/#Catlab.Algebra.Network.Block","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.Block","text":"A block of Julia code with input and output variables.\n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Catlab.Algebra.Network.compile-Tuple{Union{Block, Hom}}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.compile","text":"Compile an algebraic network into a Julia function.\n\nThis method of \"functorial compilation\" generates simple imperative code with no optimizations. Still, the code should be fast provided the original expression is properly factored, with no duplicate computations.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.compile_block-Tuple{Catlab.Algebra.Network.AlgebraicNet.Hom}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.compile_block","text":"Compile an algebraic network into a block of Julia code.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.compile_expr-Tuple{Catlab.Algebra.Network.AlgebraicNet.Hom}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.compile_expr","text":"Compile an algebraic network into a Julia function expression.\n\nThe function signature is:\n\narguments = inputs (domain) of network\nkeyword arguments = symbolic constants (coefficients) of network, if any\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.evaluate-Tuple{Catlab.Algebra.Network.AlgebraicNet.Hom,Vararg{Any,N} where N}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.evaluate","text":"Evaluate an algebraic network without first compiling it.\n\nIf the network will only be evaluated once (possibly with vectorized inputs), then direct evaluation will be much faster than compiling with Julia's JIT.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.CompileState","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.CompileState","text":"Internal state for compilation of algebraic network into Julia function.\n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Catlab.Algebra.Network.compile_expr_vector-Tuple{Catlab.Algebra.Network.AlgebraicNet.Hom}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.compile_expr_vector","text":"Compile an algebraic network into a Julia function expression.\n\nThe function signature is:\n\nfirst argument = input vector\nsecond argument = constant (coefficients) vector\n\nUnlike compile_expr, this method assumes the network has a single output.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.genconst-Tuple{Catlab.Algebra.Network.CompileState,Symbol}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.genconst","text":"Generate a constant (symbol or expression).\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.genvar-Tuple{Catlab.Algebra.Network.CompileState}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.genvar","text":"Generate a fresh variable (symbol).\n\nThis is basically gensym with local, not global, symbol counting.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.multiple_assign_expr-Tuple{Array{T,1} where T,Array{T,1} where T}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.multiple_assign_expr","text":"Generate Julia expression for single or multiple assignment.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.sum_expr-Tuple{Type,Array{T,1} where T}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.sum_expr","text":"Generate Julia expression for sum of zero, one, or more terms.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Syntax.show_latex-Tuple{IO,Catlab.Algebra.Network.AlgebraicNet.Hom{:compose}}","page":"Catlab.Algebra API","title":"Catlab.Syntax.show_latex","text":"Denote composition by a semicolon ala the computer scientists.\n\nIn this context, ⋅ is too easily confused for multiplication,  (space) is too implicit, and ∘ has a right-to-left connotation.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Network.AlgebraicNet.Hom","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.AlgebraicNet.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Catlab.Algebra.Network.AlgebraicNet.Ob","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.AlgebraicNet.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Catlab.Algebra.Network.AlgebraicNetSignature.Hom","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.AlgebraicNetSignature.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Catlab.Algebra.Network.AlgebraicNetSignature.Ob","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.AlgebraicNetSignature.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Catlab.Algebra.Tree","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree","text":"Expression trees for computer algebra.\n\nThis module is not an implementation of a conventional, general-purpose CAS. There are already many outstanding CAS's. Its goals are to\n\ndisplay formulas in conventional notation with free variables\nfacilitate interop with existing CAS's\n\n\n\n\n\n","category":"module"},{"location":"apis/algebra/#Catlab.Algebra.Tree.Formula","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree.Formula","text":"An expression tree for computer algebra.\n\nWe call these \"formulas\" to avoid confusion with Julia expressions (Base.Expr) and GAT expressions (Catlab.Syntax.GATExpr). The operations (head symbols) are interpreted as Julia functions, e.g., :/ is right multiplication by the matrix pseudoinverse while :./ is the elementwise division.\n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Base.Meta.show_sexpr-Tuple{Catlab.Algebra.Tree.Formula}","page":"Catlab.Algebra API","title":"Base.Meta.show_sexpr","text":"Show the formula as an S-expression.\n\nCf. the standard library function Meta.show_sexpr.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Tree.to_formula-Tuple{Catlab.Algebra.Network.AlgebraicNet.Hom,Array{Symbol,1}}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree.to_formula","text":"Convert algebraic network to formula.\n\nAssumes that the network has a single output.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Tree.to_formula-Tuple{Expr}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree.to_formula","text":"Convert Julia expression to formula.\n\nOnly a subset of the Julia syntax is supported.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Syntax.show_latex-Tuple{Catlab.Algebra.Tree.Formula}","page":"Catlab.Algebra API","title":"Catlab.Syntax.show_latex","text":"Show the expression in infix notation using LaTeX math.\n\nDoes not include $ or \\[begin|end]{equation} delimiters.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.WiringDiagrams.WiringDiagramCore.to_wiring_diagram-Tuple{Catlab.Algebra.Tree.Formula,Array{Symbol,1}}","page":"Catlab.Algebra API","title":"Catlab.WiringDiagrams.WiringDiagramCore.to_wiring_diagram","text":"Convert a formula, or formulas, to a wiring diagram.\n\nThe wiring diagram has an input for each symbol in vars and an output for each given formula. All terminal symbols not appearing in vars are treated as symbolic constants.\n\nThe algorithm creates wiring diagrams in normal form for a cartesian category, meaning that subformulas are maximally shared (cf. normalize_copy! for wiring diagrams and the congruence closure algorithm).\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Tree.##instance_doc#568","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree.##instance_doc#568","text":"Algebraic networks realized by formulas with free variables.\n\nThese methods should only be used with gensym-ed variables since they assume that any two formulas have disjoint variables.\n\n\n\n\n\n","category":"type"},{"location":"apis/algebra/#Catlab.Algebra.Network.evaluate-Tuple{Catlab.Algebra.Tree.Formula,Dict}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Network.evaluate","text":"Evaluate a formula, optionally with vectorization.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Tree.substitute-Tuple{Catlab.Algebra.Tree.Formula,Dict}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree.substitute","text":"Simultaneous substitution of variables in formula.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Tree.substitute-Tuple{Expr,Dict}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree.substitute","text":"Simultaneous substitution of symbols in Julia expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/algebra/#Catlab.Algebra.Tree.sum_formulas-Tuple{Type,Array{T,1} where T}","page":"Catlab.Algebra API","title":"Catlab.Algebra.Tree.sum_formulas","text":"Create formula for sum of zero, one, or more terms.\n\n\n\n\n\n","category":"method"},{"location":"apis/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"apis/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"apis/graphics/#Catlab.Graphics-API-1","page":"Catlab.Graphics API","title":"Catlab.Graphics API","text":"","category":"section"},{"location":"apis/graphics/#","page":"Catlab.Graphics API","title":"Catlab.Graphics API","text":"CurrentModule = Catlab.Graphics","category":"page"},{"location":"apis/graphics/#","page":"Catlab.Graphics API","title":"Catlab.Graphics API","text":"Modules = [Graphviz,\n           GraphvizWiringDiagrams,\n           TikZ,\n           TikZWiringDiagrams,\n           TikZWiringDiagrams.Defaults,\n          ]","category":"page"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz","page":"Catlab.Graphics API","title":"Catlab.Graphics.Graphviz","text":"AST and pretty printer for Graphviz's DOT language.\n\nReferences:\n\nDOT grammar: http://www.graphviz.org/doc/info/lang.html\nDOT language guide: http://www.graphviz.org/pdf/dotguide.pdf\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.pprint-Tuple{Catlab.Graphics.Graphviz.Expression}","page":"Catlab.Graphics API","title":"Catlab.Graphics.Graphviz.pprint","text":"Pretty-print the Graphviz expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.run_graphviz-Tuple{Catlab.Graphics.Graphviz.Graph}","page":"Catlab.Graphics API","title":"Catlab.Graphics.Graphviz.run_graphviz","text":"Run a Graphviz program.\n\nAssumes that Graphviz is installed on the local system and invokes Graphviz through its command-line interface.\n\nFor bindings to the Graphviz C API, see the the GraphViz.jl package (https://github.com/Keno/GraphViz.jl). GraphViz.jl is unmaintained at the time of this writing.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.to_graphviz-Tuple{MetaGraphs.AbstractMetaGraph}","page":"Catlab.Graphics API","title":"Catlab.Graphics.Graphviz.to_graphviz","text":"Convert an attributed graph (MetaGraph) to a Graphviz graph.\n\nThis method is usually more convenient than direct AST manipulation for creating Graphviz graphs. It supports graphs that are directed or undirected, simple or multi-edged. For more advanced features, like nested subgraphs, you must use the Graphviz AST directly.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.Html","page":"Catlab.Graphics API","title":"Catlab.Graphics.Graphviz.Html","text":"AST type for Graphviz's \"HTML-like\" node labels.\n\nThe HTML is represented as an atomic string, for now.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams","text":"Draw wiring diagrams (aka string diagrams) using Graphviz.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.Graphviz.to_graphviz-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.Graphics API","title":"Catlab.Graphics.Graphviz.to_graphviz","text":"Render a wiring diagram using Graphviz.\n\nThe input f can also be a morphism expression, which is converted into a wiring diagram.\n\nArguments\n\ngraph_name=\"G\": name of Graphviz digraph\ndirection=:vertical: layout direction. Either :vertical (top to bottom) or :horizontal (left to right).\nnode_labels=true: whether to label the nodes\nlabels=false: whether to label the edges\nlabel_attr=:label: what kind of edge label to use (if labels is true). One of :label, :xlabel, :headlabel, or :taillabel.\nport_size=\"24\": minimum size of ports on box, in points\n'outer_ports=true': whether to display the outer box's input and output ports. If disabled, no incoming or outgoing wires will be shown either!\nanchor_outer_ports=true: whether to enforce ordering of the outer box's input and output, i.e., ordering of the incoming and outgoing wires\ngraph_attrs=default_graph_attrs: top-level graph attributes\nnode_attrs=default_node_attrs: top-level node attributes\nedge_attrs=default_edge_attrs: top-level edge attributes\ncell_attrs=default_cell_attrs: main cell attributes in node HTML-like label\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.edge_label-Tuple{Any}","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.edge_label","text":"Create a label for an edge.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.escape_html-Tuple{AbstractString}","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.escape_html","text":"Escape special HTML characters: &, <, >, \", '\n\nBorrowed from HttpCommon package: https://github.com/JuliaWeb/HttpCommon.jl\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.node_label-Tuple{Any}","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.node_label","text":"Create a label for the main content of a box.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.node_left_right_html_label-Tuple{Int64,Int64,String}","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.node_left_right_html_label","text":"Create a left-to-right \"HTML-like\" node label for a box.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.node_top_bottom_html_label-Tuple{Int64,Int64,String}","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.node_top_bottom_html_label","text":"Create a top-to-bottom \"HTML-like\" node label for a box.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.port_nodes-Tuple{Int64,Catlab.WiringDiagrams.WiringDiagramCore.PortKind,Int64}","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.port_nodes","text":"Create invisible nodes for the input or output ports of an outer box.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.ports_horizontal_html_label","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.ports_horizontal_html_label","text":"Create horizontal \"HTML-like\" label for the input or output ports of a box.\n\n\n\n\n\n","category":"function"},{"location":"apis/graphics/#Catlab.Graphics.GraphvizWiringDiagrams.ports_vertical_html_label","page":"Catlab.Graphics API","title":"Catlab.Graphics.GraphvizWiringDiagrams.ports_vertical_html_label","text":"Create vertical \"HTML-like\" label for the input or output ports of a box.\n\n\n\n\n\n","category":"function"},{"location":"apis/graphics/#Catlab.Graphics.TikZ","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZ","text":"AST and pretty printer for TikZ.\n\nThis module does not provide bindings to the TikZ LaTeX package. For that, see the TikzPictures.jl package: https://github.com/sisl/TikzPictures.jl\n\nThe AST is large but still incomplete! It supports:\n\nNodes (\\node) and edges (\\draw)\nNodes along edges (\\draw ... node ...)\nGraphs (\\graph)\nMatrices (\\matrix)\nScopes and nested pictures\n\nThe AST is adapted from the (also incomplete) BNF grammar for TikZ in TikZit.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.TikZ.pprint-Tuple{Catlab.Graphics.TikZ.Expression}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZ.pprint","text":"Pretty-print the TikZ expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams","text":"Draw wiring diagrams (aka string diagrams) using TikZ.\n\n\n\n\n\n","category":"module"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.to_tikz-Tuple{Catlab.Doctrines.HomExpr}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.to_tikz","text":"Draw a wiring diagram in TikZ for the given morphism expression.\n\nThe diagram is constructed recursively, mirroring the structure of the formula. This is achieved by nesting TikZ pictures in TikZ nodes recursively–a feature not officially supported by TikZ but that is nonetheless in widespread use.\n\nWarning: Since our implementation uses the remember picture option, LaTeX must be run at least twice to fully render the picture. See (TikZ Manual, Sec 17.13).\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.Box","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.Box","text":"A box in a TikZ wiring diagram.\n\nA Box is a graphical representation of a morphism, and need not be rendered as a geometric box (rectangle).\n\n\n\n\n\n","category":"type"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.Port","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.Port","text":"A port on a box in a TikZ wiring diagram.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.Wire","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.Wire","text":"A wire (edge) in a TikZ wiring diagram.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.Wires","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.Wires","text":"A bundle of wires in a TikZ wiring diagram.\n\nA graphical representation of an object.\n\n\n\n\n\n","category":"type"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.box-Tuple{String,Catlab.Doctrines.HomExpr}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.box","text":"Create box for a morphism expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.box_ports-Tuple{Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1},String}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.box_ports","text":"Create ports for a rectangular box.\n\nThis mainly involves computing the locations of anchors. The anchors are consistent with the monoidal product (see box_size).\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.box_size-Tuple{Int64}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.box_size","text":"Compute the size of a box from the number of its ports.\n\nWe use the unique formula consistent with the monoidal product, meaning that the size of a product of generator boxes depends only on the total number of ports, not the number of generators.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.cap-Tuple{String,Catlab.Graphics.TikZWiringDiagrams.Wire,Catlab.Graphics.TikZWiringDiagrams.Wire}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.cap","text":"A cap.\n\nUsed to draw unit morphisms in compact closed categories.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.circle_ports-Tuple{Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1},String,String}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.circle_ports","text":"Create ports for a circular node.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.crossing-Tuple{String,Catlab.Graphics.TikZWiringDiagrams.Wire,Catlab.Graphics.TikZWiringDiagrams.Wire}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.crossing","text":"Cross two wires.\n\nUsed to draw braid morphisms in symmatric monoidal categories.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.cup-Tuple{String,Catlab.Graphics.TikZWiringDiagrams.Wire,Catlab.Graphics.TikZWiringDiagrams.Wire}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.cup","text":"A cup.\n\nUsed to draw counit morphisms in compact closed categories.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.junction_circle-Tuple{String,Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1},Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1}}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.junction_circle","text":"A junction of wires drawn as a circle.\n\nUsed to morphisms in internal monoids and comonoids.\n\nImplemented using a small, visible node for the point and a big, invisible node as a spacer. FIXME: Is there a more elegant way to achieve the desired margin?\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.lines-Tuple{String,Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1}}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.lines","text":"Straight lines, used to draw identity morphisms.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.parallel-Tuple{String,Array{T,1} where T}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.parallel","text":"Boxes in parallel, used to draw monoidal products.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.rect-Tuple{String,String,Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1},Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1}}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.rect","text":"A rectangle, the default style for generators.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.sequence-Tuple{String,Array{T,1} where T}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.sequence","text":"Boxes in sequence, used to draw compositions.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.trapezium-Tuple{String,String,Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1},Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1}}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.trapezium","text":"A trapezium node, the default style for generators in dagger categories.\n\nThe node content is a nested TikZ picture that contains a single visible node. Nesting pictures even at this level may seem crazy, but it's the only way I know to get a bounding box on the inner node, regardless of its shape, before it's rendered.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.triangle-Tuple{String,String,Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1},Array{Catlab.Graphics.TikZWiringDiagrams.Wire,1}}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.triangle","text":"A triangle node.\n\nSupports any number of inputs and outputs, but looks best with at most one input and at most one output.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.wires-Tuple{Catlab.Doctrines.ObExpr}","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.wires","text":"Create wires for an object expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/graphics/#Catlab.Graphics.TikZWiringDiagrams.Defaults","page":"Catlab.Graphics API","title":"Catlab.Graphics.TikZWiringDiagrams.Defaults","text":"Default renderers for specific syntax systems.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines-API-1","page":"Catlab.Doctrines API","title":"Catlab.Doctrines API","text":"","category":"section"},{"location":"apis/doctrines/#","page":"Catlab.Doctrines API","title":"Catlab.Doctrines API","text":"CurrentModule = Catlab","category":"page"},{"location":"apis/doctrines/#","page":"Catlab.Doctrines API","title":"Catlab.Doctrines API","text":"Modules = [Doctrines,\n          Catlab.Doctrines.AbelianBicategoryRelations,\n          Catlab.Doctrines.BicategoryRelations,\n          Catlab.Doctrines.BiproductCategory,\n          Catlab.Doctrines.CartesianCategory,\n          Catlab.Doctrines.CartesianClosedCategory,\n          Catlab.Doctrines.Category,\n          Catlab.Doctrines.Category2,\n          Catlab.Doctrines.CocartesianCategory,\n          Catlab.Doctrines.CompactClosedCategory,\n          Catlab.Doctrines.DaggerCategory,\n          Catlab.Doctrines.DaggerCompactCategory,\n          Catlab.Doctrines.FreeAbelianBicategoryRelations,\n          Catlab.Doctrines.FreeBicategoryRelations,\n          Catlab.Doctrines.FreeBiproductCategory,\n          Catlab.Doctrines.FreeCartesianCategory,\n          Catlab.Doctrines.FreeCartesianClosedCategory,\n          Catlab.Doctrines.FreeCategory,\n          Catlab.Doctrines.FreeCategory2,\n          Catlab.Doctrines.FreeCocartesianCategory,\n          Catlab.Doctrines.FreeCompactClosedCategory,\n          Catlab.Doctrines.FreeDaggerCategory,\n          Catlab.Doctrines.FreeDaggerCompactCategory,\n          Catlab.Doctrines.FreeSymmetricMonoidalCategory,\n          Catlab.Doctrines.MonoidalCategory,\n          Catlab.Doctrines.MonoidalCategoryWithBidiagonals,\n          Catlab.Doctrines.MonoidalCategoryWithCodiagonals,\n          Catlab.Doctrines.MonoidalCategoryWithDiagonals,\n          Catlab.Doctrines.SymmetricMonoidalCategory,\n          ]","category":"page"},{"location":"apis/doctrines/#Catlab.Doctrines.AbelianBicategoryRelations","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.AbelianBicategoryRelations","text":"Doctrine of abelian bicategory of relations\n\nUnlike Carboni & Walters, we use additive notation and nomenclature.\n\nReferences:\n\nCarboni & Walters, 1987, \"Cartesian bicategories I\", Sec. 5\nBaez & Erbele, 2015, \"Categories in control\"\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.BicategoryRelations","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.BicategoryRelations","text":"Doctrine of bicategory of relations\n\nTODO: The 2-morphisms are missing. I haven't decided how to handle them yet.\n\nReferences:\n\nCarboni & Walters, 1987, \"Cartesian bicategories I\"\nWalters, 2009, blog post, \"Categorical algebras of relations\", http://rfcwalters.blogspot.com/2009/10/categorical-algebras-of-relations.html\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.BiproductCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.BiproductCategory","text":"Doctrine of bicategory category\n\nAlso known as a semiadditive category.\n\nFIXME: This signature should extend MonoidalCategoryWithBidiagonals, CartesianCategory, and CocartesianCategory, but we don't support multiple inheritance.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CartesianCategory","text":"Doctrine of cartesian category\n\nActually, this is a cartesian symmetric monoidal category but we omit these qualifiers for brevity.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianClosedCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CartesianClosedCategory","text":"Doctrine of cartesian closed category (aka, CCC)\n\nA CCC is a cartesian category with internal homs (aka, exponential objects).\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.Category","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.Category","text":"Doctrine of category (with no extra structure)\n\nWarning: We compose functions from left to right, i.e., if f:A→B and g:B→C then compose(f,g):A→C. Under this convention function are applied on the right, e.g., if a∈A then af∈B.\n\nWe retain the usual meaning of the symbol ∘ (\\circ), i.e., g∘f = compose(f,g). This usage is too entrenched to overturn, inconvenient though it may be. We use symbol ⋅ (\\cdot) for diagrammatic composition: f⋅g = compose(f,g).\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.Category2","text":"Doctrine of (strict) 2-category\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CocartesianCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CocartesianCategory","text":"Doctrine of cocartesian category\n\nActually, this is a cocartesian symmetric monoidal category but we omit these qualifiers for brevity.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.CompactClosedCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CompactClosedCategory","text":"Doctrine of compact closed category\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.DaggerCategory","text":"Doctrine of dagger category\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCompactCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.DaggerCompactCategory","text":"Doctrine of dagger compact category\n\nFIXME: This signature should extend both DaggerCategory and CompactClosedCategory, but we don't support multiple inheritance yet.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCartesianCategory","text":"Syntax for a free cartesian category.\n\nIn this syntax, the pairing and projection operations are defined using duplication and deletion, and do not have their own syntactic elements. Of course, this convention could be reversed.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianClosedCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCartesianClosedCategory","text":"Syntax for a free cartesian closed category.\n\nSee also FreeCartesianCategory.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCategory2","text":"Syntax for a 2-category.\n\nChecks domains of morphisms but not 2-morphisms.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCocartesianCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCocartesianCategory","text":"Syntax for a free cocartesian category.\n\nIn this syntax, the copairing and inclusion operations are defined using merging and creation, and do not have their own syntactic elements. Of course, this convention could be reversed.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategory","text":"Doctrine of monoidal category\n\nTo avoid associators and unitors, we assume the monoidal category is strict. By the coherence theorem there is no loss of generality, but we may add a signature for weak monoidal categories later.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithBidiagonals","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithBidiagonals","text":"Doctrine of monoidal category with bidiagonals\n\nThe terminology is nonstandard (is there any standard terminology?) but is intended to mean a monoidal category with coherent diagonals and codiagonals. Unlike in a biproduct category, the naturality axioms need not be satisfied.\n\nFIXME: This signature should extend both MonoidalCategoryWithDiagonals and MonoidalCategoryWithCodiagonals, but we don't support multiple inheritance.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithCodiagonals","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithCodiagonals","text":"Doctrine of monoidal category with codiagonals\n\nA monoidal category with codiagonals is a symmetric monoidal category equipped with coherent collections of merging and creating morphisms (monoids). Unlike in a cocartesian category, the naturality axioms need not be satisfied.\n\nFor references, see MonoidalCategoryWithDiagonals.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithDiagonals","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithDiagonals","text":"Doctrine of monoidal category with diagonals\n\nA monoidal category with diagonals is a symmetric monoidal category equipped with coherent collections of copying and deleting morphisms (comonoids). Unlike in a cartesian category, the naturality axioms need not be satisfied.\n\nReferences:\n\nSelinger, 2010, \"A survey of graphical languages for monoidal categories\", Section 6.6: \"Cartesian center\"\nSelinger, 1999, \"Categorical structure of asynchrony\"\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Catlab.Doctrines.SymmetricMonoidalCategory","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.SymmetricMonoidalCategory","text":"Doctrine of symmetric monoidal category\n\nThe signature (but not the axioms) is the same as a braided monoidal category.\n\n\n\n\n\n","category":"module"},{"location":"apis/doctrines/#Base.collect-Tuple{Catlab.Doctrines.ObExpr}","page":"Catlab.Doctrines API","title":"Base.collect","text":"Collect generators of object in monoidal category as a vector.\n\n\n\n\n\n","category":"method"},{"location":"apis/doctrines/#Base.ndims-Tuple{Catlab.Doctrines.ObExpr}","page":"Catlab.Doctrines API","title":"Base.ndims","text":"Number of \"dimensions\" of object in monoidal category.\n\n\n\n\n\n","category":"method"},{"location":"apis/doctrines/#Catlab.Doctrines.AbelianBicategoryRelations.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.AbelianBicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.AbelianBicategoryRelations.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.AbelianBicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BicategoryRelations.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.BicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BicategoryRelations.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.BicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BiproductCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.BiproductCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.BiproductCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.BiproductCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianClosedCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CartesianClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CartesianClosedCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CartesianClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.Category.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.Category.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.Category2.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2.Hom2","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.Category2.Hom2","text":"2-morphism in a 2-category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.Category2.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.Category2.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CocartesianCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CocartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CocartesianCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CocartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CompactClosedCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CompactClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.CompactClosedCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.CompactClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.DaggerCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.DaggerCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCompactCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.DaggerCompactCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.DaggerCompactCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.DaggerCompactCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeAbelianBicategoryRelations.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeAbelianBicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeAbelianBicategoryRelations.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeAbelianBicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBicategoryRelations.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeBicategoryRelations.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBicategoryRelations.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeBicategoryRelations.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBiproductCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeBiproductCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeBiproductCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeBiproductCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianClosedCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCartesianClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCartesianClosedCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCartesianClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCategory2.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2.Hom2","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCategory2.Hom2","text":"2-morphism in a 2-category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCategory2.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCategory2.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCocartesianCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCocartesianCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCocartesianCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCocartesianCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCompactClosedCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCompactClosedCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeCompactClosedCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeCompactClosedCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeDaggerCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeDaggerCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCompactCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeDaggerCompactCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeDaggerCompactCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeDaggerCompactCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeSymmetricMonoidalCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeSymmetricMonoidalCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.FreeSymmetricMonoidalCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.FreeSymmetricMonoidalCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithBidiagonals.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithCodiagonals.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithDiagonals.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithDiagonals.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.MonoidalCategoryWithDiagonals.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.MonoidalCategoryWithDiagonals.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.SymmetricMonoidalCategory.Hom","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.SymmetricMonoidalCategory.Hom","text":"Morphism in a category \n\n\n\n\n\n","category":"type"},{"location":"apis/doctrines/#Catlab.Doctrines.SymmetricMonoidalCategory.Ob","page":"Catlab.Doctrines API","title":"Catlab.Doctrines.SymmetricMonoidalCategory.Ob","text":"Object in a category \n\n\n\n\n\n","category":"type"},{"location":"#Catlab.jl-Documentation-1","page":"Catlab.jl","title":"Catlab.jl Documentation","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"CurrentModule = Catlab","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab is an experimental library for computational category theory, written in Julia. It aims to provide a programming library and interactive interface for applications of category theory to the mathematical sciences. It emphasizes monoidal categories due to their wide applicability but can support any categorical doctrine that is formalizable as a generalized algebraic theory. An early inspiration for Catlab is the Julia library Cateno.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Warning: This is experimental software. Important features are missing, the API is unstable, and the documentation and examples are sparse. However, it is already useable for some purposes. Contributions are welcome!","category":"page"},{"location":"#What-is-it?-1","page":"Catlab.jl","title":"What is it?","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab is (or will eventually be!) the following things.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Programming library: First and foremost, Catlab provides data structures, algorithms, and serialization for applied category theory. Macros offer a convenient syntax for specifying categorical doctrines and type-safe symbolic manipulation systems. Wiring diagrams (aka string diagrams) are supported through specialized data structures and can be serialized to and from GraphML (an XML-based graph format).","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Interactive computing environment: Catlab can also be used interactively in Jupyter notebooks. Symbolic expressions are displayed using LaTeX and wiring diagrams are visualized using Graphviz or TikZ. The TikZ wiring diagrams are suitable for publication.","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Computer algebra system: Catlab will serve as a computer algebra system for category theory. Unlike most computer algebra systems, all expressions are typed using fragment of dependent type theory called generalized algebraic theories. We will implement core algorithms for solving word problems and reducing expressions in normal form, with respect to several important doctrines, such as the doctrine of categories and the doctrine of symmetric monoidal categories.","category":"page"},{"location":"#What-is-it-not?-1","page":"Catlab.jl","title":"What is it not?","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Catlab is not any of the following things. (We do not rule out that Catlab could eventually evolve in these directions but they are not our current focus.)","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Automated theorem prover: Catlab is not designed to be a general-purpose automated theorem prover for category theory. Under the current plan, its proof capabilities will be confined to carefully circumscribed algebraic problems like normalization and word problems. Also, the system does not produce formal certificates of correctness (aka proofs).","category":"page"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Proof assistant: Likewise, Catlab is not a proof assistant because it does not produce formally verifiable proofs.","category":"page"},{"location":"#Table-of-Contents-1","page":"Catlab.jl","title":"Table of Contents","text":"","category":"section"},{"location":"#","page":"Catlab.jl","title":"Catlab.jl","text":"Pages = [\n     \"index.md\",\n     \"apis/index.md\",\n     \"apis/catlab.md\",\n     \"apis/algebra.md\",\n     \"apis/doctrines.md\",\n     \"apis/graphics.md\",\n     \"apis/wiringdiagrams.md\",\n     ]\nDepth = 3","category":"page"},{"location":"apis/catlab/#Catlab-API-1","page":"Catlab API","title":"Catlab API","text":"","category":"section"},{"location":"apis/catlab/#","page":"Catlab API","title":"Catlab API","text":"CurrentModule = Catlab","category":"page"},{"location":"apis/catlab/#","page":"Catlab API","title":"Catlab API","text":"Modules = [GAT,\n           Meta,\n           Present,\n           Rewrite,\n           Syntax,\n          ]","category":"page"},{"location":"apis/catlab/#Catlab.GAT","page":"Catlab API","title":"Catlab.GAT","text":"Generalized algebraic theories (GATs) in Julia.\n\nGATs generalize (multisorted) algebraic theories by incorporating a fragment of dependent type theory. They allow type and term constructors to be partially defined. GATs provide a convenient formal syntax for categorical structures.\n\nAt present, this module only supports defining the signature of a GAT. In the future we may allow axioms to be expressed as well. Regardless, we will persist in calling this module \"GAT\". Signatures are defined using the @signature macro.\n\nThere are several useful things to do with a GAT signature:\n\nDefine instances of the signature (models of the theory) in Julia code using the @instance macro\nDefine syntax systems using the @syntax macro (see Syntax module)\nDefine models of the theory by finite presentation using a syntax system and the @present macro (see Present module)\n\nReferences:\n\n(Cartmell, 1986, \"Generalized algebraic theories and contextual categoies\")\n(Pitts, 1995, \"Categorical logic\", Sec 6: \"Dependent types\")\n\n\n\n\n\n","category":"module"},{"location":"apis/catlab/#Catlab.GAT.invoke_term-Tuple{Module,Tuple,Symbol,Vararg{Any,N} where N}","page":"Catlab API","title":"Catlab.GAT.invoke_term","text":"Invoke a term constructor by name on an instance.\n\nThis method provides reflection for GAT signatures. In everyday use the generic method for the constructor should be called directly, not through this function.\n\nCf. Julia's builtin invoke() function.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.@instance-Tuple{Any,Any}","page":"Catlab API","title":"Catlab.GAT.@instance","text":"Define an instance of a generalized algebraic theory (GAT).\n\nThese are perfectly analagous to instances of a type class in Haskell. See also the Typeclass.jl library for Julia.\n\n\n\n\n\n","category":"macro"},{"location":"apis/catlab/#Catlab.GAT.@signature-Tuple{Any,Any}","page":"Catlab API","title":"Catlab.GAT.@signature","text":"Define a signature of a generalized algebraic theory (GAT).\n\nThree kinds of things can go in the signature body:\n\nType constructors, indicated by the special type TYPE, e.g. Hom(X::Ob,Y::Ob)::TYPE\nTerm constructors, e.g., id(X::Ob)::Hom(X,X)\nJulia functions operating on the term constructors to provide additional functionality\n\nA signature can extend existing signatures (at present only one).\n\n\n\n\n\n","category":"macro"},{"location":"apis/catlab/#Catlab.GAT.Signature","page":"Catlab API","title":"Catlab.GAT.Signature","text":"Signature for a generalized algebraic theory (GAT).\n\n\n\n\n\n","category":"type"},{"location":"apis/catlab/#Catlab.GAT.Stub","page":"Catlab API","title":"Catlab.GAT.Stub","text":"Base type for method stubs in GAT signature.\n\n\n\n\n\n","category":"type"},{"location":"apis/catlab/#Catlab.GAT.TermConstructor","page":"Catlab API","title":"Catlab.GAT.TermConstructor","text":"Term constructor in a GAT.\n\n\n\n\n\n","category":"type"},{"location":"apis/catlab/#Catlab.GAT.TypeConstructor","page":"Catlab API","title":"Catlab.GAT.TypeConstructor","text":"Type constructor in a GAT.\n\n\n\n\n\n","category":"type"},{"location":"apis/catlab/#Catlab.GAT.Typeclass","page":"Catlab API","title":"Catlab.GAT.Typeclass","text":"Typeclass = GAT signature + Julia-specific content.\n\n\n\n\n\n","category":"type"},{"location":"apis/catlab/#Catlab.GAT.accessors-Tuple{Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.accessors","text":"Julia functions for type parameter accessors.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.add_type_dispatch-Tuple{Expr,Union{Expr, Symbol}}","page":"Catlab API","title":"Catlab.GAT.add_type_dispatch","text":"Add a type-valued first argument to a Julia function signature.\n\nWe need this to avoid ambiguity in method dispatch when a term constructor has no arguments (e.g., munit()) or more generally has no arguments that are types in the signature (e.g., object generators in a category).\n\nThe fundamental reason why these cases must be treated specially is that Julia does not (yet?) support dispatching on return type.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.constructors-Tuple{Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.constructors","text":"Julia functions for term constructors of GAT.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.equations-Tuple{Array{Symbol,1},OrderedCollections.OrderedDict{Symbol,Union{Expr, Symbol}},Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.equations","text":"Implicit equations defined by context, allowing for implicit variables.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.equations-Tuple{Catlab.GAT.TermConstructor,Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.equations","text":"Implicit equations for term constructor.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.equations-Tuple{OrderedCollections.OrderedDict{Symbol,Union{Expr, Symbol}},Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.equations","text":"Implicit equations defined by a context.\n\nThis function allows a generalized algebraic theory (GAT) to be expressed as an essentially algebraic theory, i.e., as partial functions whose domains are defined by equations.\n\nReferences:\n\n(Cartmell, 1986, Sec 6: \"Essentially algebraic theories and categories with   finite limits\")\n(Freyd, 1972, \"Aspects of topoi\")\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.expand_in_context-Tuple{Any,Array{Symbol,1},OrderedCollections.OrderedDict{Symbol,Union{Expr, Symbol}},Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.expand_in_context","text":"Expand context variables that occur implicitly in an expression.\n\nReference: (Cartmell, 1986, Sec 10: 'Informal syntax').\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.expand_term_type-Tuple{Catlab.GAT.TermConstructor,Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.expand_term_type","text":"Expand context variables that occur implicitly in the type expression  of a term constructor.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.gen_abstract_type-Tuple{Catlab.GAT.TypeConstructor}","page":"Catlab API","title":"Catlab.GAT.gen_abstract_type","text":"Generate abstract type definition from a GAT type constructor.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.get_type-Tuple{Catlab.GAT.Signature,Symbol}","page":"Catlab API","title":"Catlab.GAT.get_type","text":"Get type constructor by name.\n\nUnlike term constructors, type constructors cannot be overloaded, so there is at most one type constructor with a given name.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.interface-Tuple{Catlab.GAT.Typeclass}","page":"Catlab API","title":"Catlab.GAT.interface","text":"Complete set of Julia functions for a type class.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.parse_constructor-Tuple{Expr}","page":"Catlab API","title":"Catlab.GAT.parse_constructor","text":"Parse type or term constructor in a GAT.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.parse_context-Tuple{Expr}","page":"Catlab API","title":"Catlab.GAT.parse_context","text":"Parse context for term or type in a GAT.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.parse_instance_body-Tuple{Expr}","page":"Catlab API","title":"Catlab.GAT.parse_instance_body","text":"Parse the body of a GAT instance definition.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.parse_raw_expr-Tuple{Any}","page":"Catlab API","title":"Catlab.GAT.parse_raw_expr","text":"Parse a raw expression in a GAT.\n\nA \"raw expression\" is a just composition of function and constant symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.parse_signature_body-Tuple{Expr}","page":"Catlab API","title":"Catlab.GAT.parse_signature_body","text":"Parse the body of a GAT signature declaration.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.replace_types-Tuple{Dict,Catlab.GAT.Signature}","page":"Catlab API","title":"Catlab.GAT.replace_types","text":"Replace names of type constructors in a GAT.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.strip_type-Tuple{Any}","page":"Catlab API","title":"Catlab.GAT.strip_type","text":"Remove type parameters from dependent type.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta","page":"Catlab API","title":"Catlab.Meta","text":"General-purpose tools for metaprogramming in Julia.\n\n\n\n\n\n","category":"module"},{"location":"apis/catlab/#Catlab.Meta.append_expr!-Tuple{Expr,Any}","page":"Catlab API","title":"Catlab.Meta.append_expr!","text":"Append a Julia expression to a block expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.concat_expr-Tuple{Expr,Expr}","page":"Catlab API","title":"Catlab.Meta.concat_expr","text":"Concatenate two Julia expressions into a block expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.generate_docstring-Tuple{Expr,Union{Nothing, String}}","page":"Catlab API","title":"Catlab.Meta.generate_docstring","text":"Wrap Julia expression with docstring.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.generate_function-Tuple{Catlab.Meta.JuliaFunction}","page":"Catlab API","title":"Catlab.Meta.generate_function","text":"Generate Julia expression for function definition.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.parse_docstring-Tuple{Expr}","page":"Catlab API","title":"Catlab.Meta.parse_docstring","text":"Parse Julia expression that is (possibly) annotated with docstring.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.parse_function-Tuple{Expr}","page":"Catlab API","title":"Catlab.Meta.parse_function","text":"Parse Julia function definition into standardized form.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.parse_function_sig-Tuple{Expr}","page":"Catlab API","title":"Catlab.Meta.parse_function_sig","text":"Parse signature of Julia function.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.replace_symbols-Tuple{AbstractDict,Any}","page":"Catlab API","title":"Catlab.Meta.replace_symbols","text":"Replace symbols occuring anywhere in a Julia expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.replace_symbols-Tuple{AbstractDict,Catlab.Meta.JuliaFunction}","page":"Catlab API","title":"Catlab.Meta.replace_symbols","text":"Replace symbols occurring anywhere in a Julia function (except the name).\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Meta.strip_lines-Tuple{Expr}","page":"Catlab API","title":"Catlab.Meta.strip_lines","text":"Remove all LineNumberNodes from a Julia expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present","page":"Catlab API","title":"Catlab.Present","text":"Finite presentations of a model of a generalized algebraic theory (GAT).\n\nWe support two methods for defining models of a GAT: as Julia objects using the @instance macro and as syntactic objects using the @present macro. Instances are useful for casting generic data structures, such as matrices, abstract tensor systems, and wiring diagrams, in categorical language. Presentations define small categories by generators and relations and are useful for applications like knowledge representation.\n\n\n\n\n\n","category":"module"},{"location":"apis/catlab/#Catlab.Present.add_definition!-Tuple{Presentation,Symbol,GATExpr}","page":"Catlab API","title":"Catlab.Present.add_definition!","text":"Add a generator defined by an equation.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.add_equation!-Tuple{Presentation,GATExpr,GATExpr}","page":"Catlab API","title":"Catlab.Present.add_equation!","text":"Add an equation between terms to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.add_generator!-Union{Tuple{T}, Tuple{Presentation{T},GATExpr{:generator}}} where T","page":"Catlab API","title":"Catlab.Present.add_generator!","text":"Add a generator to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.add_generators!-Tuple{Presentation,Any}","page":"Catlab API","title":"Catlab.Present.add_generators!","text":"Add multiple generators to a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.equations-Tuple{Presentation}","page":"Catlab API","title":"Catlab.Present.equations","text":"Get all equations of a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.generator-Union{Tuple{T}, Tuple{Presentation{T},Any}} where T","page":"Catlab API","title":"Catlab.Present.generator","text":"Retrieve a generator by name.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.generators-Tuple{Presentation}","page":"Catlab API","title":"Catlab.Present.generators","text":"Get all generators of a presentation.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.has_generator-Union{Tuple{T}, Tuple{Presentation{T},Any}} where T","page":"Catlab API","title":"Catlab.Present.has_generator","text":"Does the presentation contain a generator with the given name?\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.merge_presentation!-Union{Tuple{T}, Tuple{Presentation{T},Presentation{T}}} where T","page":"Catlab API","title":"Catlab.Present.merge_presentation!","text":"Merge the second presentation into the first.\n\nThe first presentation is mutated and returned; the second is not.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.@present-Tuple{Any,Any}","page":"Catlab API","title":"Catlab.Present.@present","text":"Define a presentation using a convenient syntax.\n\n\n\n\n\n","category":"macro"},{"location":"apis/catlab/#Catlab.Present.translate_definition-Tuple{Symbol,Any}","page":"Catlab API","title":"Catlab.Present.translate_definition","text":"Translate definition of generator in terms of other generators.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.translate_equation-Tuple{Any,Any}","page":"Catlab API","title":"Catlab.Present.translate_equation","text":"Translate declaration of equality between terms.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.translate_expr-Tuple{Symbol,Expr}","page":"Catlab API","title":"Catlab.Present.translate_expr","text":"Translate a single statement in the presentation DSL to Julia code.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.translate_generator-Tuple{Symbol,Union{Nothing, Symbol},Any}","page":"Catlab API","title":"Catlab.Present.translate_generator","text":"Translate declaration of a generator.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Present.translate_presentation-Tuple{Symbol,Expr}","page":"Catlab API","title":"Catlab.Present.translate_presentation","text":"Translate a presentation in the DSL to a block of Julia code.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Rewrite","page":"Catlab API","title":"Catlab.Rewrite","text":"Rewriting for GAT expressions.\n\nThe current content of this module is just a stopgap until I can implement a generic term rewriting system.\n\n\n\n\n\n","category":"module"},{"location":"apis/catlab/#Catlab.Rewrite.anti_involute-Tuple{GATExpr,Function,Function,Function}","page":"Catlab API","title":"Catlab.Rewrite.anti_involute","text":"Simplify unary operation that is an anti-involution on a (typed) monoid.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Rewrite.associate-Union{Tuple{E}, Tuple{E}} where E<:GATExpr","page":"Catlab API","title":"Catlab.Rewrite.associate","text":"Simplify associative binary operation.\n\nMaintains the normal form op(e1,e2,...) where e1,e2,... are expressions that are not applications of op()\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Rewrite.associate_unit-Tuple{GATExpr,Function}","page":"Catlab API","title":"Catlab.Rewrite.associate_unit","text":"Simplify associative binary operation with unit.\n\nReduces a freely generated (typed) monoid to normal form.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Rewrite.distribute_unary-Tuple{GATExpr,Function,Function}","page":"Catlab API","title":"Catlab.Rewrite.distribute_unary","text":"Distribute unary operation over a binary operation.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax","page":"Catlab API","title":"Catlab.Syntax","text":"Syntax for a generalized algebraic theory (GAT).\n\nUnlike instances of a theory, syntactic expressions don't necessarily satisfy the equations of the theory. For example, the default syntax operations for the Category theory don't form a category because they don't satisfy the category laws, e.g.,\n\ncompose(f, id(A)) != compose(f)\n\nWhether dependent types are enforced at runtime and whether expressions are automatically brought to normal form depends on the particular syntax. In general, a single theory may have many different syntaxes. The purpose of this module to make the construction of syntax simple but flexible.\n\n\n\n\n\n","category":"module"},{"location":"apis/catlab/#Catlab.Syntax.GATExpr","page":"Catlab API","title":"Catlab.Syntax.GATExpr","text":"Base type for expression in the syntax of a GAT.\n\nWe define Julia types for each type constructor in the theory, e.g., object, morphism, and 2-morphism in the theory of 2-categories. Of course, Julia's type system does not support dependent types, so the type parameters are incorporated in the Julia types. (They are stored as extra data in the expression instances.)\n\nThe concrete types are structurally similar to the core type Expr in Julia. However, the term constructor is represented as a type parameter, rather than as a head field. This makes dispatch using Julia's type system more convenient.\n\n\n\n\n\n","category":"type"},{"location":"apis/catlab/#Base.Meta.show_sexpr-Tuple{GATExpr}","page":"Catlab API","title":"Base.Meta.show_sexpr","text":"Show the syntax expression as an S-expression.\n\nCf. the standard library function Meta.show_sexpr.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.GAT.invoke_term-Tuple{Module,Symbol,Vararg{Any,N} where N}","page":"Catlab API","title":"Catlab.GAT.invoke_term","text":"Invoke a term constructor by name in a syntax system.\n\nThis method provides reflection for syntax systems. In everyday use the generic method for the constructor should be called directly, not through this function.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.functor-Tuple{Tuple,GATExpr}","page":"Catlab API","title":"Catlab.Syntax.functor","text":"Functor from GAT expression to GAT instance.\n\nStrictly speaking, we should call these \"structure-preserving functors\" or, better, \"model homomorphisms of GATs\". But this is a category theory library, so we'll go with the simpler \"functor\".\n\nA functor is completely determined by its action on the generators. There are several ways to specify this mapping:\n\nSimply specify a Julia instance type for each doctrine type, using the required types tuple. For this to work, the generator constructors must be defined for the instance types.\nExplicitly map each generator term to an instance value, using the generators dictionary.\n\nFor each doctrine type (e.g., object and morphism), specify a function mapping generator terms of that type to an instance value, using the terms dictionary.\n\nThe terms dictionary can also be used for special handling of non-generator expressions. One use case for this capability is defining forgetful functors, which map non-generators to generators.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.parse_json_sexpr-Tuple{Module,Any}","page":"Catlab API","title":"Catlab.Syntax.parse_json_sexpr","text":"Deserialize expression from JSON-able S-expression.\n\nIf symbols is true (the default), strings are converted to symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.show_latex-Tuple{GATExpr}","page":"Catlab API","title":"Catlab.Syntax.show_latex","text":"Show the expression in infix notation using LaTeX math.\n\nDoes not include $ or \\[begin|end]{equation} delimiters.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.show_unicode-Tuple{GATExpr}","page":"Catlab API","title":"Catlab.Syntax.show_unicode","text":"Show the expression in infix notation using Unicode symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.to_json_sexpr-Tuple{GATExpr}","page":"Catlab API","title":"Catlab.Syntax.to_json_sexpr","text":"Serialize expression as JSON-able S-expression.\n\nThe format is an S-expression encoded as JSON, e.g., \"compose(f,g)\" is represented as [\"compose\", f, g].\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.@syntax","page":"Catlab API","title":"Catlab.Syntax.@syntax","text":"Define a syntax system for a generalized algebraic theory (GAT).\n\nA syntax system consists of Julia types (with top type GATExpr) for each type constructor in the signature, plus Julia functions for\n\nGenerators: creating new generator terms, e.g., objects or morphisms\nAccessors: accessing type parameters, e.g., domains and codomains\nTerm constructors: applying term constructors, e.g., composition and monoidal products\n\nJulia code for all this is generated by the macro. Any of the methods can be overriden with custom simplification logic.\n\n\n\n\n\n","category":"macro"},{"location":"apis/catlab/#Catlab.Syntax.constructor_name-Tuple{GATExpr}","page":"Catlab API","title":"Catlab.Syntax.constructor_name","text":"Name of constructor that created expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.gen_term_constructor-Tuple{Catlab.GAT.TermConstructor,Catlab.GAT.Signature,Module}","page":"Catlab API","title":"Catlab.Syntax.gen_term_constructor","text":"Generate methods for syntax term constructors.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.gen_term_constructor_params-Tuple{Any,Any,Any}","page":"Catlab API","title":"Catlab.Syntax.gen_term_constructor_params","text":"Generate expressions for type parameters of term constructor.\n\nBesides expanding the implicit variables, we must handle two annoying issues:\n\nAdd types for method dispatch where necessary (see GAT.add_type_dispatch) FIXME: We are currently only handling the nullary case (e.g., munit()). To handle the general case, we need to do basic type inference.\nRebind the term constructors to ensure that user overrides are preferred over the default term constructors.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.gen_term_generator-Tuple{Catlab.GAT.TypeConstructor,Catlab.GAT.Signature,Module}","page":"Catlab API","title":"Catlab.Syntax.gen_term_generator","text":"Generate methods for term generators.\n\nGenerators are extra term constructors created automatically for the syntax.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.gen_type","page":"Catlab API","title":"Catlab.Syntax.gen_type","text":"Generate syntax type definitions.\n\n\n\n\n\n","category":"function"},{"location":"apis/catlab/#Catlab.Syntax.gen_type_accessors-Tuple{Catlab.GAT.TypeConstructor}","page":"Catlab API","title":"Catlab.Syntax.gen_type_accessors","text":"Generate accessor methods for type parameters.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.generator_like-Tuple{GATExpr,Any}","page":"Catlab API","title":"Catlab.Syntax.generator_like","text":"Create generator of the same type as the given expression.\n\n\n\n\n\n","category":"method"},{"location":"apis/catlab/#Catlab.Syntax.interface-Tuple{Catlab.GAT.Typeclass}","page":"Catlab API","title":"Catlab.Syntax.interface","text":"Complete set of Julia functions for a syntax system.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams-API-1","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams API","text":"","category":"section"},{"location":"apis/wiringdiagrams/#","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams API","text":"CurrentModule = Catlab.WiringDiagrams","category":"page"},{"location":"apis/wiringdiagrams/#","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams API","text":"Modules = [WiringDiagramCore,\n           WiringLayers,\n           WiringDiagramAlgorithms,\n           GraphMLWiringDiagrams,\n           WiringDiagramSerialization,\n           JSONWiringDiagrams,\n           YFilesWiringDiagrams,\n          ]","category":"page"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore","text":"Generic data structure for wiring diagrams (aka, string diagrams).\n\nA (directed) wiring diagram consists of a collection of boxes with input and output ports connected by wires. A box can be atomic (possessing no internal structure) or can itself be a wiring diagram. Thus, wiring diagrams can be nested recursively. Wiring diagrams are closely related to what the CS literature calls \"directed graphs with ports\" or more simply \"port graphs\". The main difference is that a wiring diagram has an \"outer box\": a wiring diagram has its own ports that can be connected to the ports of its boxes.\n\nThis module offers a generic data structure for wiring diagrams. Arbitrary data can be attached to the boxes, ports, and wires of a wiring diagram. There is a low-level interface for direct manipulation of boxes and wires and a high-level interface based on the theory of symmetric monoidal categories. \n\nThe wiring diagrams in this module are \"abstract\" in the sense that they cannot be directly rendered as raster or vector graphics. However, they form a useful intermediate representation that can be straightforwardly serialized to and from GraphML or translated into Graphviz or other declarative diagram languages.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.AbstractBox","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.AbstractBox","text":"Base type for any box (node) in a wiring diagram.\n\nThis type represents an arbitrary black box with inputs and outputs.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Box","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.Box","text":"An atomic box in a wiring diagram.\n\nThese boxes have no internal structure.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Box-Tuple{Catlab.Doctrines.HomExpr{:generator}}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.Box","text":"Create box for a morphism generator.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Port","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.Port","text":"A port on a box to which wires can be connected.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.PortKind","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.PortKind","text":"Kind of port: input or output.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.PortValueError","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.PortValueError","text":"Error thrown when the source and target ports of a wire are incompatible.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Ports","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.Ports","text":"List of ports: object in the category of wiring diagrams.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.Wire","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.Wire","text":"A wire connecting one port to another.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram","text":"Wiring diagram: morphism in the category of wiring diagrams.\n\nThe wiring diagram is implemented using the following internal data structures. A LightGraphs DiGraph stores the \"skeleton\" of the diagram: a simple directed graph with the boxes as vertices and with an edge between two vertices iff there is at least one wire between the corresponding boxes. There are two special vertices, accessible via input_id and output_id, representing the input and output ports, respectively.\n\nThe DiGraph is wrapped inside a MetaDiGraph to attach properties to the vertices and edges. For each edge, an edge property stores the list of wires between the source and target boxes.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram-Tuple{Catlab.Doctrines.ObExpr,Catlab.Doctrines.ObExpr}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram","text":"Create empty wiring diagram with given domain and codomain objects.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.encapsulate!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Array{Int64,1},1}}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.encapsulate!","text":"Simultaneous encapsulation of boxes.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.encapsulate!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1}}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.encapsulate!","text":"Encapsulate multiple boxes within a single sub wiring diagram.\n\nThis operation is a (one-sided) inverse to subsitution (see substitute!).\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.graph-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.graph","text":"Retrieve the underlying LightGraphs graph.\n\nDo not mutate it! All mutations should pass through the WiringDiagram methods: add_box!, rem_box!, etc.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.in_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Catlab.WiringDiagrams.WiringDiagramCore.Port}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.in_wires","text":"Get all wires coming into the port.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.in_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.in_wires","text":"Get all wires coming into the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.is_permuted_equal-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1}}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.is_permuted_equal","text":"Check equality of wiring diagram under permutation of boxes.\n\nWhen the boxes in the first diagram d1 are permuted according to σ, does it become identical to the second diagram d2?\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.out_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Catlab.WiringDiagrams.WiringDiagramCore.Port}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.out_wires","text":"Get all wires coming out of the port.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.out_wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.out_wires","text":"Get all wires coming out of the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.substitute!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1},Array{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,1}}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.substitute!","text":"Simultaneous substitution of wiring diagrams for vertices.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.substitute!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64,Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.substitute!","text":"Substitute a wiring diagram for a vertex.\n\nThis operation is the operadic composition of wiring diagrams.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.to_wiring_diagram-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.AbstractBox}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.to_wiring_diagram","text":"Create wiring diagram with a single box connected to outer ports.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.validate_ports-Tuple{Any,Any}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.validate_ports","text":"Check compatibility of source and target ports.\n\nThrows a PortValueError when the ports are incompatible. The default implementation of this method is a no-op.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.wires-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.wires","text":"Get all wires coming into or out of the box.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.##instance_doc#548","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.##instance_doc#548","text":"Wiring diagram as monoidal category with diagonals and codiagonals.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.PortEdgeData","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.PortEdgeData","text":"Internal data structure corresponding to Port. Do not use directly.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.WireEdgeData","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.WireEdgeData","text":"Internal data structure corresponding to Wire. Do not use directly.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Base.:==-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Base.:==","text":"Check equality of wiring diagrams.\n\nWarning: This method checks exact equality of the underlying graph representation, not mathematical equality which involves graph isomorphism.\n\nSee also: is_permuted_equal\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore._substitute_insert!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64,Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore._substitute_insert!","text":"The insertion phase of a substitution operation.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramCore.encapsulated_ports-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1},Int64}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramCore.encapsulated_ports","text":"Create input and output ports for encapsulating box.\n\nAny port of the boxes vs that has an incoming (resp. outgoing) wire from a box outside of vs will become an input (resp. output) port of the encapsulating box.\n\nA set of box ports connected to the same (set of) outside ports will be simplified into a single port of the encapsulating box. This simplification is only relevant when duplication or merging is used, as in a cartesian or cocartesian category.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringLayers","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringLayers","text":"Data structure for connecting one layer to another by wires.\n\nThis module defines a generic data structure to represent a wiring between one layer of input ports and another layer of output ports. A wiring layer forms a bipartite graph with independent edge sets the input ports and the output ports.\n\nWiring layers are an auxillary data structure. They are not very interesting in their own right, but they can be a useful intermediate representation. For example, a morphism expression comprising generators, compositions, products, and wiring layers is intermediate between a pure GAT expression (which has no wiring layers, but may have identities, braidings, copies, etc.) and a wiring diagram, which is purely graphical.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringLayers.NLayer","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringLayers.NLayer","text":"Number of input or output ports in a layer.\n\nObject in the category of wiring layers.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringLayers.WiringLayer","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringLayers.WiringLayer","text":"Connection by wires of one layer to another.\n\nMorphism in the category of wiring layers.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringLayers.wiring_layer_between-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Int64,Int64}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringLayers.wiring_layer_between","text":"Wiring layer representing the wires between two boxes in a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringLayers.##instance_doc#549","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringLayers.##instance_doc#549","text":"Wiring layers as monoidal category with diagonals and codiagonals.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms","text":"Algorithms operating on wiring diagrams.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.Junction","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.Junction","text":"Junction node in a wiring diagram.\n\nUsed to explicitly represent copies, merges, deletions, and creations.\n\n\n\n\n\n","category":"type"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.add_junctions!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.add_junctions!","text":"Add junction nodes to wiring diagram.\n\nTransforms from implicit to explicit representation of (co)diagonals.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.crossing_minimization_by_sort-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,Array{Int64,1},Array{Int64,1}}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.crossing_minimization_by_sort","text":"One-sided crossing minimization by sorting a univariate statistic.\n\nThe boxes in sources are fixed and the boxes in targets are permuted. A permutation σ of the latter is returned, such that targets[σ] are the sorted box IDs.\n\nIn this popular heuristic algorithm, the boxes are permuted by sorting a univariate statistic of the positions of incoming wires. Typical choices are:\n\nmean: the sample mean, yielding the \"barycenter method\"\nmedian: the sample median\n\nIn both cases, this algorithm has the property that if there is a permutation with no crossings, it will find it.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_cartesian!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_cartesian!","text":"Put a wiring diagram for a cartesian category into normal form.\n\nThis function puts a wiring diagram representing a morphism in a free cartesian category into normal form. Copies and deletions are simplified as much as possible.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_copy!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_copy!","text":"Normalize copies in a wiring diagram.\n\nThis function maximizes sharing of intermediate computations in a wiring diagram where copies are natural.\n\nThis algorithm is basically the same as the congruence closure algorithm on term graphs, in the special case of the empty relation R = ∅ (Baader & Nipkow, 1998, Term Rewriting and All That, Sec. 4.4). The main difference is the possibility of zero or many function outputs.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_delete!-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.normalize_delete!","text":"Normalize deletions in a wiring diagram.\n\nThis function removes all unused intermediate computations in a wiring diagram where deletion is natural.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramAlgorithms.topological_sort-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramAlgorithms.topological_sort","text":"Topological sort of boxes in wiring diagram.\n\nReturns a list of box IDs, excluding the outer box's input and output IDs.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams","text":"Serialize abstract wiring diagrams as GraphML.\n\nSerialization of box, port, and wire values can be overloaded by data type (see convert_to_graphml_data and convert_from_graphml_data).\n\nGraphML is the closest thing to a de jure and de facto standard in the space of graph data formats, supported by a variety of graph applications and libraries. We depart mildly from the GraphML spec by allowing JSON data attributes for GraphML nodes, ports, and edges.\n\nReferences:\n\nGraphML Primer: http://graphml.graphdrawing.org/primer/graphml-primer.html\nGraphML DTD: http://graphml.graphdrawing.org/specification/dtd.html\n\n\n\n\n\n","category":"module"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.generate_graphml-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.generate_graphml","text":"Generate GraphML representing a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml-Tuple{Type,Type,Type,AbstractString}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml","text":"Parse a wiring diagram from a GraphML string or XML document.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml-Tuple{Type,Type,Type,String}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml","text":"Read a wiring diagram from a GraphML file.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.write_graphml-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,String}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.write_graphml","text":"Write a wiring diagram to a file as GraphML.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml_metagraph-Tuple{AbstractString}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.parse_graphml_metagraph","text":"Parse an attributed graph from a GraphML string or XML document.\n\nThe equivalent of NetworkX's parse_graphml function.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml_metagraph-Tuple{String}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.GraphMLWiringDiagrams.read_graphml_metagraph","text":"Read an attributed graph (MetaGraph) from a GraphML file.\n\nThe equivalent of NetworkX's read_graphml function.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.WiringDiagramSerialization","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.WiringDiagramSerialization","text":"Conventions for serialization of wiring diagrams.\n\nDefines a consistent set of names for boxes, ports, and wires to be used when serializing wiring diagrams, as well as conventions for serializing box, port, and wire attributes.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.JSONWiringDiagrams","text":"Serialize abstract wiring diagrams as JSON.\n\nJSON data formats are convenient when programming for the web. Unfortunately, no standard for JSON graph formats has gained any kind of widespread adoption. We adopt a format compatible with that used by the KEILER project and its successor ELK (Eclipse Layout Kernel). This format is roughly feature compatible with GraphML, supporting nested graphs and ports. It also supports layout information like node position and size.\n\nReferences:\n\nKEILER's JSON graph format: https://rtsys.informatik.uni-kiel.de/confluence/display/KIELER/JSON+Graph+Format\nELK's JSON graph format: https://www.eclipse.org/elk/documentation/tooldevelopers/graphdatastructure/jsonformat.html\n\n\n\n\n\n","category":"module"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.generate_json_graph-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.generate_json_graph","text":"Generate a JSON dict representing a wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.parse_json_graph-Tuple{Type,Type,Type,Union{AbstractString, IO}}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.parse_json_graph","text":"Parse a wiring diagram from a JSON string or dict.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.read_json_graph-Tuple{Type,Type,Type,String}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.read_json_graph","text":"Read a wiring diagram from a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.JSONWiringDiagrams.write_json_graph-Tuple{Catlab.WiringDiagrams.WiringDiagramCore.WiringDiagram,String}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.JSONWiringDiagrams.write_json_graph","text":"Write a wiring diagram to a file as JSON.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.YFilesWiringDiagrams","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.YFilesWiringDiagrams","text":"Deserialize abstract wiring diagram from yFiles.\n\nReads a wiring diagram from the GraphML dialect used by yEd and yFiles. Unlike the GraphML spec, the yEd data model does not explicitly include ports:\n\nhttps://yed.yworks.com/support/qa/102/\nhttps://yed.yworks.com/support/qa/2531/\n\nWe infer the ports of boxes and their order from the geometry of the diagram. Thus, this module has the nature of a hack. While it may be useful for interactive and exploratory work, it should not be used in a production system.\n\n\n\n\n\n","category":"module"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.YFilesWiringDiagrams.parse_yfiles_diagram-Tuple{Type,Type,AbstractString}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.YFilesWiringDiagrams.parse_yfiles_diagram","text":"Parse a wiring diagram from a GraphML string or XML doc created by yFiles.\n\n\n\n\n\n","category":"method"},{"location":"apis/wiringdiagrams/#Catlab.WiringDiagrams.YFilesWiringDiagrams.read_yfiles_diagram-Tuple{Type,Type,String}","page":"Catlab.WiringDiagrams API","title":"Catlab.WiringDiagrams.YFilesWiringDiagrams.read_yfiles_diagram","text":"Read a wiring diagram from a GraphML file created by yEd and yFiles.\n\n\n\n\n\n","category":"method"}]
}
