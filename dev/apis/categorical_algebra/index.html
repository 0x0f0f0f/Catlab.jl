<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Categorical algebra · Catlab.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Catlab.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Wiring diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li class="is-active"><a class="tocitem" href>Categorical algebra</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li><a class="tocitem" href="../programs/">Programs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Categorical algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Categorical algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/categorical_algebra.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="categorical_algebra"><a class="docs-heading-anchor" href="#categorical_algebra">Categorical algebra</a><a id="categorical_algebra-1"></a><a class="docs-heading-anchor-permalink" href="#categorical_algebra" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams" href="#Catlab.CategoricalAlgebra.FreeDiagrams"><code>Catlab.CategoricalAlgebra.FreeDiagrams</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Free diagrams in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/free+diagram">free diagram</a> in a category is a diagram whose shape is a free category. Examples include the empty diagram, pairs of objects, discrete diagrams, parallel morphisms, spans, and cospans. Limits and colimits are most commonly taken over free diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Cospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Cospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Cospan of morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Multicospan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.DiscreteDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discrete diagram: a diagram whose only morphisms are identities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram" href="#Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram"><code>Catlab.CategoricalAlgebra.FreeDiagrams.FixedShapeFreeDiagram</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for free diagram of fixed shape.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multicospan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multicospan of morphisms in a category.</p><p>A multicospan is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a> except that it may have a number of legs different than two. A limit of this shape is a pullback.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Multispan" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Multispan</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multispan of morphisms in a category.</p><p>A <a href="https://ncatlab.org/nlab/show/multispan">multispan</a> is like a <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Span</code></a> except that it may have a number of legs different than two. A colimit of this shape is a pushout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parallel morphims in a category.</p><p><a href="https://ncatlab.org/nlab/show/parallel+morphisms">Parallel morphisms</a> are just morphisms with the same domain and codomain. A (co)limit of this shape is a (co)equalizer.</p><p>For the common special case of two morphisms, see <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>ParallelPair</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair" href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair"><code>Catlab.CategoricalAlgebra.FreeDiagrams.ParallelPair</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pair of parallel morphisms in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.ParallelMorphisms"><code>ParallelMorphisms</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FreeDiagrams.Span" href="#Catlab.CategoricalAlgebra.FreeDiagrams.Span"><code>Catlab.CategoricalAlgebra.FreeDiagrams.Span</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Span of morphims in a category.</p><p>A common special case of <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Multispan"><code>Multispan</code></a>. See also <a href="#Catlab.CategoricalAlgebra.FreeDiagrams.Cospan"><code>Cospan</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits" href="#Catlab.CategoricalAlgebra.Limits"><code>Catlab.CategoricalAlgebra.Limits</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Limits and colimits in a category.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractColimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractColimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractColimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for colimit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Colimit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.AbstractLimit" href="#Catlab.CategoricalAlgebra.Limits.AbstractLimit"><code>Catlab.CategoricalAlgebra.Limits.AbstractLimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for limit in a category.</p><p>The standard concrete subtype is <a href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Limit</code></a>, although for computational reasons certain categories may use different subtypes to include extra data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Colimit" href="#Catlab.CategoricalAlgebra.Limits.Colimit"><code>Catlab.CategoricalAlgebra.Limits.Colimit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Colimit in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.Limit" href="#Catlab.CategoricalAlgebra.Limits.Limit"><code>Catlab.CategoricalAlgebra.Limits.Limit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Limit in a category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.colimit" href="#Catlab.CategoricalAlgebra.Limits.colimit"><code>Catlab.CategoricalAlgebra.Limits.colimit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Colimit of a diagram.</p><p>To define colimits in a category with objects <code>Ob</code>, override the method <code>colimit(::FreeDiagram{Ob})</code> for general colimits or <code>colimit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for colimits of specific shape, such as coproducts or coequalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit"><code>limit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.composite_pullback-Tuple{Multicospan{Ob,var&quot;#s135&quot;} where var&quot;#s135&quot;&lt;:(StaticArrays.StaticArray{Tuple{2},T,1} where T) where Ob}" href="#Catlab.CategoricalAlgebra.Limits.composite_pullback-Tuple{Multicospan{Ob,var&quot;#s135&quot;} where var&quot;#s135&quot;&lt;:(StaticArrays.StaticArray{Tuple{2},T,1} where T) where Ob}"><code>Catlab.CategoricalAlgebra.Limits.composite_pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute pullback as composite of product and equalizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.composite_pushout-Tuple{Multispan{Ob,var&quot;#s135&quot;} where var&quot;#s135&quot;&lt;:(StaticArrays.StaticArray{Tuple{2},T,1} where T) where Ob}" href="#Catlab.CategoricalAlgebra.Limits.composite_pushout-Tuple{Multispan{Ob,var&quot;#s135&quot;} where var&quot;#s135&quot;&lt;:(StaticArrays.StaticArray{Tuple{2},T,1} where T) where Ob}"><code>Catlab.CategoricalAlgebra.Limits.composite_pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute pushout as composite of coproduct and coequalizer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.limit" href="#Catlab.CategoricalAlgebra.Limits.limit"><code>Catlab.CategoricalAlgebra.Limits.limit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Limit of a diagram.</p><p>To define limits in a category with objects <code>Ob</code>, override the method <code>limit(::FreeDiagram{Ob})</code> for general limits or <code>limit(::D)</code> with suitable type <code>D &lt;: FixedShapeFreeDiagram{Ob}</code> for limits of specific shape, such as products or equalizers.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.colimit"><code>colimit</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any,Any}" href="#Catlab.CategoricalAlgebra.Limits.pullback-Tuple{Any,Any}"><code>Catlab.CategoricalAlgebra.Limits.pullback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pullback of a pair of morphisms with common codomain.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::Cospan{T})</code> and/or <code>limit(::Multicospan{T})</code> or, if you have already implemented products and equalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any,Any}" href="#Catlab.CategoricalAlgebra.Limits.pushout-Tuple{Any,Any}"><code>Catlab.CategoricalAlgebra.Limits.pushout</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushout of a pair of morphisms with common domain.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::Span{T})</code> and/or <code>colimit(::Multispan{T})</code> or, if you have already implemented coproducts and coequalizers, rely on the default implementation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Limits.universal" href="#Catlab.CategoricalAlgebra.Limits.universal"><code>Catlab.CategoricalAlgebra.Limits.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Universal property of (co)limits.</p><p>Compute the morphism whose existence and uniqueness is guaranteed by the universal property of (co)limits.</p><p>See also: <a href="#Catlab.CategoricalAlgebra.Limits.limit"><code>limit</code></a>, <a href="#Catlab.CategoricalAlgebra.Limits.colimit"><code>colimit</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.copair-Tuple{Any,Any}" href="#Catlab.Theories.copair-Tuple{Any,Any}"><code>Catlab.Theories.copair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copairing of morphisms: universal property of coproducts/pushouts.</p><p>To implement for coproducts of type <code>T</code>, define the method <code>universal(::BinaryCoproduct{T}, ::Cospan{T})</code> and/or <code>universal(::Coproduct{T}, ::Multicospan{T})</code> and similarly for pushouts.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.coproduct-Tuple{Any,Any}" href="#Catlab.Theories.coproduct-Tuple{Any,Any}"><code>Catlab.Theories.coproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Coproduct of objects.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::ObjectPair{T})</code> and/or <code>colimit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.create-Tuple{T} where T" href="#Catlab.Theories.create-Tuple{T} where T"><code>Catlab.Theories.create</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism out of an initial object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Initial{T}, ::SMulticospan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.delete-Tuple{T} where T" href="#Catlab.Theories.delete-Tuple{T} where T"><code>Catlab.Theories.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unique morphism into a terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>universal(::Terminal{T}, ::SMultispan{0,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.factorize-Tuple{AbstractLimit{Ob,var&quot;#s135&quot;} where var&quot;#s135&quot;&lt;:ParallelMorphisms where Ob,Any}" href="#Catlab.Theories.factorize-Tuple{AbstractLimit{Ob,var&quot;#s135&quot;} where var&quot;#s135&quot;&lt;:ParallelMorphisms where Ob,Any}"><code>Catlab.Theories.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Factor morphism through (co)equalizer, via the universal property.</p><p>To implement for equalizers of type <code>T</code>, define the method <code>universal(::Equalizer{T}, ::SMultispan{1,T})</code>. For coequalizers of type <code>T</code>, define the method <code>universal(::Coequalizer{T}, ::SMulticospan{1,T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.initial-Tuple{Type}" href="#Catlab.Theories.initial-Tuple{Type}"><code>Catlab.Theories.initial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initial object.</p><p>To implement for a type <code>T</code>, define the method <code>colimit(::EmptyDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.pair-Tuple{Any,Any}" href="#Catlab.Theories.pair-Tuple{Any,Any}"><code>Catlab.Theories.pair</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairing of morphisms: universal property of products/pullbacks.</p><p>To implement for products of type <code>T</code>, define the method <code>universal(::BinaryProduct{T}, ::Span{T})</code> and/or <code>universal(::Product{T}, ::Multispan{T})</code> and similarly for pullbacks.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.product-Tuple{Any,Any}" href="#Catlab.Theories.product-Tuple{Any,Any}"><code>Catlab.Theories.product</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Product of objects.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::ObjectPair{T})</code> and/or <code>limit(::DiscreteDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Theories.terminal-Tuple{Type}" href="#Catlab.Theories.terminal-Tuple{Type}"><code>Catlab.Theories.terminal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Terminal object.</p><p>To implement for a type <code>T</code>, define the method <code>limit(::EmptyDiagram{T})</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets" href="#Catlab.CategoricalAlgebra.FinSets"><code>Catlab.CategoricalAlgebra.FinSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Computing in the category of finite sets and functions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunction" href="#Catlab.CategoricalAlgebra.FinSets.FinFunction"><code>Catlab.CategoricalAlgebra.FinSets.FinFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function between finite sets.</p><p>The function can be defined implicitly by an arbitrary Julia function, in which case it is evaluated lazily, or explictly by a vector of integers. In the latter case, the function (1↦1, 2↦3, 3↦2, 4↦3), for example, is represented by the vector [1,3,2,3].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunctionCallable" href="#Catlab.CategoricalAlgebra.FinSets.FinFunctionCallable"><code>Catlab.CategoricalAlgebra.FinSets.FinFunctionCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function in FinSet defined by a callable Julia object.</p><p>To be evaluated lazily unless forced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinFunctionVector" href="#Catlab.CategoricalAlgebra.FinSets.FinFunctionVector"><code>Catlab.CategoricalAlgebra.FinSets.FinFunctionVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Function in FinSet represented explicitly by a vector.</p><p>The elements of the set are assumed to be {1,...,n}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.FinSet" href="#Catlab.CategoricalAlgebra.FinSets.FinSet"><code>Catlab.CategoricalAlgebra.FinSets.FinSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Finite set.</p><p>This generic type encompasses the category <strong>FinSet</strong> of finite sets and functions, through types <code>FinSet{S} where S &lt;: AbstractSet</code>, as well as the skeleton of this category, through the type <code>FinSet{Int}</code>. In the latter case, the object <code>FinSet(n)</code> represents the set {1,...,n}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinSets.force-Tuple{Catlab.CategoricalAlgebra.FinSets.FinFunction{Int64,T} where T}" href="#Catlab.CategoricalAlgebra.FinSets.force-Tuple{Catlab.CategoricalAlgebra.FinSets.FinFunction{Int64,T} where T}"><code>Catlab.CategoricalAlgebra.FinSets.force</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Force evaluation of lazy function or relation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations" href="#Catlab.CategoricalAlgebra.FinRelations"><code>Catlab.CategoricalAlgebra.FinRelations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Computing in the category of finite sets and relations, and its skeleton.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.BoolRig" href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>Catlab.CategoricalAlgebra.FinRelations.BoolRig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The rig of booleans.</p><p>This struct is needed because in base Julia, the product of booleans is another boolean, but the sum of booleans is coerced to an integer: <code>true + true == 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRel" href="#Catlab.CategoricalAlgebra.FinRelations.FinRel"><code>Catlab.CategoricalAlgebra.FinRelations.FinRel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object in the category of finite sets and relations.</p><p>See also: <code>FinSet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelation" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelation"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Binary relation between finite sets.</p><p>A morphism in the category of finite sets and relations. The relation can be represented implicitly by an arbitrary Julia function mapping pairs of elements to booleans or explicitly by a matrix (dense or sparse) taking values in the rig of booleans (<a href="#Catlab.CategoricalAlgebra.FinRelations.BoolRig"><code>BoolRig</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationCallable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel defined by a callable Julia object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix" href="#Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix"><code>Catlab.CategoricalAlgebra.FinRelations.FinRelationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Relation in FinRel represented by a boolean matrix.</p><p>Boolean matrices are also known as logical matrices or relation matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Permutations" href="#Catlab.CategoricalAlgebra.Permutations"><code>Catlab.CategoricalAlgebra.Permutations</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Computing with permutations: the computer algebra of the symmetric group.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Permutations.decompose_permutation_by_bubble_sort!-Tuple{Array{Int64,1}}" href="#Catlab.CategoricalAlgebra.Permutations.decompose_permutation_by_bubble_sort!-Tuple{Array{Int64,1}}"><code>Catlab.CategoricalAlgebra.Permutations.decompose_permutation_by_bubble_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Decompose permutation into adjacent transpositions using bubble sort.</p><p>An <em>adjacent transposition</em>, also known as a <em>simple transposition</em>, is a transposition of form (i i+1), represented here as simply the number i.</p><p>This algorithm appears as Algorithm 2.7 in the PhD thesis of Jonathan Huang, &quot;Probabilistic reasonsing and learning on permutations: Exploiting structural decompositions of the symmetric group&quot;. As Huang notes, the algorithm is very similar to the well-known bubble sort. It has quadratic complexity.</p><p>See also: <code>decompose_permutation_by_insertion_sort!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Permutations.decompose_permutation_by_insertion_sort!-Tuple{Array{Int64,1}}" href="#Catlab.CategoricalAlgebra.Permutations.decompose_permutation_by_insertion_sort!-Tuple{Array{Int64,1}}"><code>Catlab.CategoricalAlgebra.Permutations.decompose_permutation_by_insertion_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Decompose permutation into adjacent transpositions using insertion sort.</p><p>An <em>adjacent transposition</em>, also known as a <em>simple transposition</em>, is a transposition of form (i i+1), represented here as simply the number i.</p><p>Bubble sort and insertion sort are, in a sense, dual algorithms (Knuth, TAOCP, Vol 3: Searching and Sort, Sec 5.3.4: Networks for sorting, Figures 45 &amp; 46). A minimal example on which they give different decompositions is the permutation:</p><p>[1,2,3] ↦ [3,2,1]</p><p>See also: <code>decompose_permutation_by_bubble_sort!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.Permutations.permutation_to_expr-Tuple{Array{Int64,1},Array{T,1} where T}" href="#Catlab.CategoricalAlgebra.Permutations.permutation_to_expr-Tuple{Array{Int64,1},Array{T,1} where T}"><code>Catlab.CategoricalAlgebra.Permutations.permutation_to_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert a typed permutation into a morphism expression.</p><p>Warning: The morphism expression is not simplified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets" href="#Catlab.CategoricalAlgebra.CSets"><code>Catlab.CategoricalAlgebra.CSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Categories of C-sets and attributed C-sets.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.ACSetTransformation" href="#Catlab.CategoricalAlgebra.CSets.ACSetTransformation"><code>Catlab.CategoricalAlgebra.CSets.ACSetTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transformation between attributed C-sets.</p><p>A morphism of C-sets is a natural transformation: a transformation between functors C -&gt; Set satisfying the naturality axiom for all morphisms in C. This struct records the data of a transformation; it does not enforce naturality.</p><p>The transformation has a component for every object in C. When C-sets have attributes, the data types are assumed to be fixed. Thus, the naturality axiom for data attributes is a commutative triangle, rather than a commutative square.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/539f3ce943f59dec8aff3f2238b083f1b27f41e5/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.CategoricalAlgebra.CSets.is_natural-Union{Tuple{ACSetTransformation{CD,AD,Comp,Dom} where Dom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD,AD,Ts} where Ts&lt;:Tuple) where Comp&lt;:NamedTuple}, Tuple{AD}, Tuple{CD}} where AD where CD" href="#Catlab.CategoricalAlgebra.CSets.is_natural-Union{Tuple{ACSetTransformation{CD,AD,Comp,Dom} where Dom&lt;:(Catlab.CSetDataStructures.AbstractAttributedCSet{CD,AD,Ts} where Ts&lt;:Tuple) where Comp&lt;:NamedTuple}, Tuple{AD}, Tuple{CD}} where AD where CD"><code>Catlab.CategoricalAlgebra.CSets.is_natural</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Is the transformation between C-sets a natural transformation?</p><p>Uses the fact that to check whether a transformation is natural, it suffices to check the naturality equation on a generating set of morphisms.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theories/">« Standard library of theories</a><a class="docs-footer-nextpage" href="../wiring_diagrams/">Wiring diagrams »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 30 September 2020 01:43">Wednesday 30 September 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
