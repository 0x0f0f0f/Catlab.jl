<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Programs · Catlab.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Catlab.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Catlab.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Catlab.jl</a></li><li><span class="tocitem">Vignettes</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Wiring diagrams</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/wiring_diagrams/wiring_diagram_basics/">Basics of wiring diagrams</a></li><li><a class="tocitem" href="../../generated/wiring_diagrams/diagrams_and_expressions/">Wiring diagrams and syntactic expressions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Graphics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../generated/graphics/composejl_wiring_diagrams/">Drawing wiring diagrams in Compose.jl</a></li><li><a class="tocitem" href="../../generated/graphics/graphviz_wiring_diagrams/">Drawing wiring diagrams in Graphviz</a></li><li><a class="tocitem" href="../../generated/graphics/tikz_wiring_diagrams/">Drawing wiring diagrams in TikZ</a></li><li><a class="tocitem" href="../../generated/graphics/layouts_vs_drawings/">Layouts versus drawings of wiring diagrams</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../core/">Theories, instances, and expressions</a></li><li><a class="tocitem" href="../theories/">Standard library of theories</a></li><li><a class="tocitem" href="../categorical_algebra/">Categorical algebra</a></li><li><a class="tocitem" href="../wiring_diagrams/">Wiring diagrams</a></li><li><a class="tocitem" href="../graphics/">Graphics</a></li><li class="is-active"><a class="tocitem" href>Programs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Programs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Programs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Catlab.jl/blob/master/docs/src/apis/programs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="programs"><a class="docs-heading-anchor" href="#programs">Programs</a><a id="programs-1"></a><a class="docs-heading-anchor-permalink" href="#programs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms" href="#Catlab.Programs.GenerateJuliaPrograms"><code>Catlab.Programs.GenerateJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Compile or evaluate morphisms as Julia programs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.Block" href="#Catlab.Programs.GenerateJuliaPrograms.Block"><code>Catlab.Programs.GenerateJuliaPrograms.Block</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A block of Julia code with input and output variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.CompileState" href="#Catlab.Programs.GenerateJuliaPrograms.CompileState"><code>Catlab.Programs.GenerateJuliaPrograms.CompileState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Internal state for compilation of morphism into Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module,HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile-Tuple{Module,HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr,Array{T,1} where T}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_block-Tuple{HomExpr,Array{T,1} where T}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_block</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a block of Julia code.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}" href="#Catlab.Programs.GenerateJuliaPrograms.compile_expr-Tuple{HomExpr}"><code>Catlab.Programs.GenerateJuliaPrograms.compile_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compile a morphism expression into a Julia function expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr,Vararg{Any,N} where N}" href="#Catlab.Programs.GenerateJuliaPrograms.evaluate-Tuple{HomExpr,Vararg{Any,N} where N}"><code>Catlab.Programs.GenerateJuliaPrograms.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate a morphism as a function.</p><p>If the morphism will be evaluated only once (possibly with vectorized inputs), then direct evaluation will be much faster than compiling (via <code>compile</code>) and evaluating a standard Julia function.</p><p>Compare with <a href="../core/#Catlab.Syntax.functor-Tuple{Tuple,GATExpr}"><code>functor</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms" href="#Catlab.Programs.ParseJuliaPrograms"><code>Catlab.Programs.ParseJuliaPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse Julia programs into morphisms represented as wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation,Expr}" href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation,Expr}"><code>Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse a wiring diagram from a Julia function expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any,Vararg{Any,N} where N}"><code>@program</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any,Vararg{Any,N} where N}" href="#Catlab.Programs.ParseJuliaPrograms.@program-Tuple{Any,Vararg{Any,N} where N}"><code>Catlab.Programs.ParseJuliaPrograms.@program</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Parse a wiring diagram from a Julia program.</p><p>For the most part, this is standard Julia code but we take a few liberties with the syntax. Products are represented as tuples. So if <code>x</code> and <code>y</code> are variables of type <span>$X$</span> and <span>$Y$</span>, then <code>(x,y)</code> has type <span>$X \otimes Y$</span>. Also, both <code>()</code> and <code>nothing</code> are interpreted as the monoidal unit <span>$I$</span>.</p><p>Unlike in standard Julia, the call expressions <code>f(x,y)</code> and <code>f((x,y))</code> are equivalent. Consequently, given morphisms <span>$f: W \to X \otimes Y$</span> and <span>$g: X \otimes Y \to Z$</span>, the code</p><pre><code class="language-julia">x, y = f(w)
g(x,y)</code></pre><p>is equivalent to <code>g(f(w))</code>. In standard Julia, at most one of these calls to <code>g</code> would be valid, unless <code>g</code> had multiple signatures.</p><p>The diagonals (copying and deleting) are implicit in the Julia syntax: copying is variable reuse and deleting is variable non-use. For the codiagonals (merging and creating), a special syntax is provided, reinterpreting Julia&#39;s vector literals. The merge of <code>x1</code> and <code>x2</code> is represented by the vector <code>[x1,x2]</code> and creation by the empty vector <code>[]</code>. For example, <code>f([x1,x2])</code> translates to <code>compose(mmerge(X),f)</code>.</p><p>This macro is a wrapper around <a href="#Catlab.Programs.ParseJuliaPrograms.parse_wiring_diagram-Tuple{Presentation,Expr}"><code>parse_wiring_diagram</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms" href="#Catlab.Programs.RelationalPrograms"><code>Catlab.Programs.RelationalPrograms</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Parse relation expressions in Julia syntax into undirected wiring diagrams.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.compile_tensor_expr-Tuple{AbstractCSet{(:Box, :Port, :OuterPort, :Junction),(:box, :junction, :outer_junction),(2, 2, 3),(1, 4, 4),Data,DataDom} where DataDom where Data}" href="#Catlab.Programs.RelationalPrograms.compile_tensor_expr-Tuple{AbstractCSet{(:Box, :Port, :OuterPort, :Junction),(:box, :junction, :outer_junction),(2, 2, 3),(1, 4, 4),Data,DataDom} where DataDom where Data}"><code>Catlab.Programs.RelationalPrograms.compile_tensor_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate tensor expression from undirected wiring diagram.</p><p>This function is used to implement <a href="#Catlab.Programs.RelationalPrograms.@eval_tensor_network-Tuple{Any,Any}"><code>@eval_tensor_network</code></a> but may be useful in its own right.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}" href="#Catlab.Programs.RelationalPrograms.parse_relation_diagram-Tuple{Expr}"><code>Catlab.Programs.RelationalPrograms.parse_relation_diagram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse an undirected wiring diagram from a relation expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>@relation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.parse_tensor_network-Tuple{Expr,Expr}" href="#Catlab.Programs.RelationalPrograms.parse_tensor_network-Tuple{Expr,Expr}"><code>Catlab.Programs.RelationalPrograms.parse_tensor_network</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Parse an undirected wiring diagram from a tensor expression.</p><p>For more information, see the corresponding macro <a href="#Catlab.Programs.RelationalPrograms.@tensor_network-Tuple"><code>@tensor_network</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.@eval_tensor_network-Tuple{Any,Any}" href="#Catlab.Programs.RelationalPrograms.@eval_tensor_network-Tuple{Any,Any}"><code>Catlab.Programs.RelationalPrograms.@eval_tensor_network</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Evaluate a tensor network using another macro.</p><p>This macro takes two arguments: an undirected wiring diagram and a macro call supporting the tensor contraction notation that is de facto standard among Julia tensor packages. For example, to evaluate a tensor network using the <code>@tullio</code> macro, use:</p><pre><code class="language-julia">A = @eval_tensor_network diagram @tullio</code></pre><p>The following macros should work:</p><ul><li><code>@tensor</code> from <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a>.</li><li><code>@tullio</code> from <a href="https://github.com/mcabbott/Tullio.jl">Tullio.jl</a></li><li><code>@einsum</code> from <a href="https://github.com/ahwillia/Einsum.jl">Einsum.jl</a></li><li><code>@ein</code> from <a href="https://github.com/under-Peter/OMEinsum.jl">OMEinsum.jl</a></li></ul><p>However,, the macros <code>@cast</code> and <code>@reduce</code> from <a href="https://github.com/mcabbott/TensorCast.jl">TensorCast.jl</a> will <em>not</em> work because they do not support implicit summation.</p><p>See also: <a href="#Catlab.Programs.RelationalPrograms.@tensor_network-Tuple"><code>@tensor_network</code></a>, the &quot;inverse&quot; to this macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.@relation-Tuple" href="#Catlab.Programs.RelationalPrograms.@relation-Tuple"><code>Catlab.Programs.RelationalPrograms.@relation</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Construct an undirected wiring diagram using relation notation.</p><p>Unlike the <code>@program</code> macro for directed wiring diagrams, this macro fundamentally alters the usual semantics of the Julia language. Function calls with n arguments are now interpreted as assertions that an n-ary relation holds at a particular point. For example, the operation of composing of binary relations R ⊆ X × Y and S ⊆ Y × Z can be represented as an undirected wiring diagram by the macro call</p><pre><code class="language-julia">@relation (x,z) where (x::X, y::Y, z::Z) begin
  R(x,y)
  S(y,z)
end</code></pre><p>In general, the context in the <code>where</code> clause defines the set of junctions in the diagram and variable sharing defines the wiring of ports to junctions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Catlab.Programs.RelationalPrograms.@tensor_network-Tuple" href="#Catlab.Programs.RelationalPrograms.@tensor_network-Tuple"><code>Catlab.Programs.RelationalPrograms.@tensor_network</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Construct an undirected wiring diagram using tensor notation.</p><p>The tensor syntax is compatible with that used by packages like <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a> and <a href="https://github.com/mcabbott/TensorCast.jl">TensorCast.jl</a>. For example, the wiring diagram for composite of two matrices (or two binary relations) is constructed by</p><pre><code class="language-julia">@tensor_network (i,j,k) C[i,k] := A[i,j] * B[j,k]</code></pre><p>The leading context, or list of variables, may be omitted, in which case it is inferred from the variables used in the tensor expression. So, in this example, an equivalent macro call is</p><pre><code class="language-julia">@tensor_network C[i,k] := A[i,j] * B[j,k]</code></pre><p>See also: <a href="#Catlab.Programs.RelationalPrograms.@eval_tensor_network-Tuple{Any,Any}"><code>@eval_tensor_network</code></a>, the &quot;inverse&quot; to this macro.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graphics/">« Graphics</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 29 August 2020 00:12">Saturday 29 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
